1
00:00:00,240 --> 00:00:07,600
嗨大家好，歡迎來到入門 Python 教學，本系列特別專注於影像處理。在這段影片中，我們將..

2
00:00:00,240 --> 00:00:07,600
hi everyone welcome to introductory python tutorials with a special focus on image processing in this video let's

3
00:00:07,600 --> 00:00:13,200
使用我們在之前的視頻中開發的單元來執行二元語義分割

4
00:00:07,600 --> 00:00:13,200
 perform the binary semantic segmentation using the unit we have developed in the previous video

5
00:00:13,200 --> 00:00:16,480
如果你還沒看過那個視頻，我強烈建議你去看一下

6
00:00:13,200 --> 00:00:16,480
 so if you haven't watched that i definitely recommend you to watch it

7
00:00:16,480 --> 00:00:22,800
因為我們將使用完全相同的單元，這個單元是使用編碼器區塊的函數構建的

8
00:00:16,480 --> 00:00:22,800
 because we're going to use exactly the same unit that we built using functions for encoder blocks

9
00:00:22,800 --> 00:00:23,840
和解碼區塊

10
00:00:22,800 --> 00:00:23,840
 and decoded blocks

11
00:00:23,840 --> 00:00:25,279
在上一個視頻中可以

12
00:00:23,840 --> 00:00:25,279
 okay in the last video

13
00:00:25,279 --> 00:00:28,080
然後我們將執行二元語義分割

14
00:00:25,279 --> 00:00:28,080
 and then we are going to perform a binary semantic segmentation

15
00:00:28,080 --> 00:00:32,159
那麼我們所說的二進位語意分割是什麼呢？我想這很清楚

16
00:00:28,080 --> 00:00:32,159
 so what do we mean by binary semantic segmentation i think it's pretty clear

17
00:00:32,159 --> 00:00:36,719
但如果不清楚，我們假設你有一張圖片在左側，物體

18
00:00:32,159 --> 00:00:36,719
 but if not let's say you have an image on the left hand side here the object

19
00:00:36,719 --> 00:00:39,200
是要分割線粒體

20
00:00:36,719 --> 00:00:39,200
 is to segment the mitochondria

21
00:00:39,200 --> 00:00:41,040
背景之外

22
00:00:39,200 --> 00:00:41,040
 out of the background

23
00:00:41,040 --> 00:00:42,320
這個繁忙的背景之外

24
00:00:41,040 --> 00:00:42,320
 out of this busy background

25
00:00:42,320 --> 00:00:43,440
這就是二進位

26
00:00:42,320 --> 00:00:43,440
 so this is binary

27
00:00:43,440 --> 00:00:47,360
因為只有兩件事我在乎，一個是背景

28
00:00:43,440 --> 00:00:47,360
 because there are only two things i care about one background

29
00:00:47,360 --> 00:00:49,440
另一個是線粒體

30
00:00:47,360 --> 00:00:49,440
 and the other mitochondria

31
00:00:49,440 --> 00:00:52,160
我只希望這兩件事能分開

32
00:00:49,440 --> 00:00:52,160
 i only want these two things to be separated

33
00:00:52,160 --> 00:00:54,960
事實上，我只希望線粒體能夠分開

34
00:00:52,160 --> 00:00:54,960
 in fact i only want the mitochondria to be separated

35
00:00:54,960 --> 00:00:58,079
所以二元問題實際上是

36
00:00:54,960 --> 00:00:58,079
 so a binary problem is actually

37
00:00:58,079 --> 00:00:58,960
一個問題

38
00:00:58,079 --> 00:00:58,960
 a problem

39
00:00:58,960 --> 00:00:59,359
哪裡

40
00:00:58,960 --> 00:00:59,359
 where

41
00:00:59,359 --> 00:01:03,280
你專注於一種單一類型的物件

42
00:00:59,359 --> 00:01:03,280
 you are focused on one single type of object

43
00:01:03,280 --> 00:01:04,720
二進位給人一種印象

44
00:01:03,280 --> 00:01:04,720
 binary gives the impression that

45
00:01:04,720 --> 00:01:08,880
好的，你需要兩個不同的東西，但二進位制基本上是你需要一個輸出

46
00:01:04,720 --> 00:01:08,880
 okay you need two different things but binary is basically you need one output

47
00:01:08,880 --> 00:01:13,520
一個像素屬於線粒體像素的概率是多少

48
00:01:08,880 --> 00:01:13,520
 what is the probability that a pixel belongs to a pixel of mitochondria

49
00:01:13,520 --> 00:01:14,400
或

50
00:01:13,520 --> 00:01:14,400
 or

51
00:01:14,400 --> 00:01:17,600
它屬於背景，所以你需要一個輸出

52
00:01:14,400 --> 00:01:17,600
 it belongs to the background that's it so you need one output

53
00:01:17,600 --> 00:01:20,400
如果該輸出顯示為 0.1

54
00:01:17,600 --> 00:01:20,400
 if that output says 0.1

55
00:01:20,400 --> 00:01:22,720
然後我將設置一個閾值為 0.5

56
00:01:20,400 --> 00:01:22,720
 then i'll apply a threshold at 0.5

57
00:01:22,720 --> 00:01:24,159
並說它低於 0.5

58
00:01:22,720 --> 00:01:24,159
 and say it's below 0.5

59
00:01:24,159 --> 00:01:25,600
所以它必須是背景

60
00:01:24,159 --> 00:01:25,600
 so it must be background

61
00:01:25,600 --> 00:01:29,759
如果超過 0.5，那一定是線粒體，就是這麼簡單

62
00:01:25,600 --> 00:01:29,759
 if it's above 0.5 it must be mitochondria that's it it's as simple

63
00:01:29,759 --> 00:01:30,240
好的

64
00:01:29,759 --> 00:01:30,240
 okay

65
00:01:30,240 --> 00:01:32,560
所以這就是所謂的二進位語意分割

66
00:01:30,240 --> 00:01:32,560
 so that's what a binary semantic segmentation

67
00:01:32,560 --> 00:01:36,720
這就是我們如何建立一個單位

68
00:01:32,560 --> 00:01:36,720
 is and again we saw that this is how we can build a unit

69
00:01:36,720 --> 00:01:42,399
我們在這裡討論的是，你看到的是 con 2d 的輸出層

70
00:01:36,720 --> 00:01:42,399
 and all we're talking about here is you see the output layer of con 2d

71
00:01:42,399 --> 00:01:46,720
你在這裡有一個，這就是我們實際獲得的輸出

72
00:01:42,399 --> 00:01:46,720
 you have one right there this is the one output that we are actually getting right here

73
00:01:46,720 --> 00:01:48,399
這就是二元的

74
00:01:46,720 --> 00:01:48,399
 this is what a binary

75
00:01:48,399 --> 00:01:52,399
分割基本上意味著你有一個輸出就在那裡

76
00:01:48,399 --> 00:01:52,399
 segmentation basically means you have one output right there

77
00:01:52,399 --> 00:01:52,960
好的

78
00:01:52,399 --> 00:01:52,960
 okay

79
00:01:52,960 --> 00:01:53,439
和

80
00:01:52,960 --> 00:01:53,439
 and

81
00:01:53,439 --> 00:01:58,159
哦，對不起，我應該提到這一點，我們使用的是 sigmoid 激活函數

82
00:01:53,439 --> 00:01:58,159
 oh sorry i should have mentioned this one output we are using sigmoid activation

83
00:01:58,159 --> 00:02:00,799
那什麼是 sigmoid？回到視頻中

84
00:01:58,159 --> 00:02:00,799
 and what is sigmoid again go back to the video

85
00:02:00,799 --> 00:02:03,360
我在其中講過這個，但簡單解釋一下

86
00:02:00,799 --> 00:02:03,360
 where i talked about it but a quick explanation

87
00:02:03,360 --> 00:02:09,280
這是一個介於零和一之間的東西，可以把它想像成一種機率

88
00:02:03,360 --> 00:02:09,280
 this is a it goes between zero to one think of it as a probability

89
00:02:09,280 --> 00:02:10,720
使用 Sigmoid 函數

90
00:02:09,280 --> 00:02:10,720
 using sigmoid function

91
00:02:10,720 --> 00:02:11,680
你會得到一個概率

92
00:02:10,720 --> 00:02:11,680
 you get a probability

93
00:02:11,680 --> 00:02:14,160
就在那時，你可以設定一個閾值

94
00:02:11,680 --> 00:02:14,160
 right there and then you say you can set a threshold

95
00:02:14,160 --> 00:02:16,879
說如果概率低於 0.5

96
00:02:14,160 --> 00:02:16,879
 saying hey if the probability is below 0.5

97
00:02:16,879 --> 00:02:19,360
如果它高於 0.5，我會稱之為背景

98
00:02:16,879 --> 00:02:19,360
 i'm going to call it background if it's above 0.5

99
00:02:19,360 --> 00:02:21,040
這再次是我的線粒體

100
00:02:19,360 --> 00:02:21,040
 this is again my mitochondria

101
00:02:21,040 --> 00:02:22,800
再次，我知道我在重複某些事情

102
00:02:21,040 --> 00:02:22,800
 again i know i'm repeating certain things

103
00:02:22,800 --> 00:02:27,040
但這些在涉及到

104
00:02:22,800 --> 00:02:27,040
 but these are very very important when it comes to

105
00:02:27,040 --> 00:02:28,720
你知道這個話題現在

106
00:02:27,040 --> 00:02:28,720
 you know this topic right now

107
00:02:28,720 --> 00:02:29,920
好的，我們開始進入代碼部分

108
00:02:28,720 --> 00:02:29,920
 okay let's jump into the code

109
00:02:29,920 --> 00:02:32,720
現在讓這變得有點有趣

110
00:02:29,920 --> 00:02:32,720
 and make this a bit fun right now

111
00:02:32,720 --> 00:02:33,360
一如既往

112
00:02:32,720 --> 00:02:33,360
 as usual

113
00:02:33,360 --> 00:02:35,200
我會分享程式碼

114
00:02:33,360 --> 00:02:35,200
 i'll share the code

115
00:02:35,200 --> 00:02:39,120
所以再一次，請專注於我在這裡嘗試做的事情

116
00:02:35,200 --> 00:02:39,120
 so again please focus on what i'm trying to do right here

117
00:02:39,120 --> 00:02:42,400
所以在 Google Colab 中，第一步你可以做任何事

118
00:02:39,120 --> 00:02:42,400
 so step number one in google collab you can do whatever

119
00:02:42,400 --> 00:02:44,480
我正在您的本地電腦上顯示

120
00:02:42,400 --> 00:02:44,480
 i'm showing on your local computer

121
00:02:44,480 --> 00:02:44,800
但

122
00:02:44,480 --> 00:02:44,800
 but

123
00:02:44,800 --> 00:02:47,440
如果你有好的 GPU，就是那種你知道的

124
00:02:44,800 --> 00:02:47,440
 if you have good gpu that's you know with

125
00:02:47,440 --> 00:02:50,400
一切安裝順利，否則嘗試使用 Colab

126
00:02:47,440 --> 00:02:50,400
 everything installed great otherwise try to use collab

127
00:02:50,400 --> 00:02:52,480
因為您不需要擔心

128
00:02:50,400 --> 00:02:52,480
 because you don't have to worry about

129
00:02:52,480 --> 00:02:53,519
安裝 GPU

130
00:02:52,480 --> 00:02:53,519
 gpus installing

131
00:02:53,519 --> 00:02:57,200
然後首先更改運行時類型，它已經是 GPU

132
00:02:53,519 --> 00:02:57,200
 and all that so first of all change the runtime type it's already gpu

133
00:02:57,200 --> 00:02:58,480
所以我沒問題

134
00:02:57,200 --> 00:02:58,480
 so i'm good

135
00:02:58,480 --> 00:03:00,000
並讓我繼續連接

136
00:02:58,480 --> 00:03:00,000
 and let me go ahead and connect

137
00:03:00,000 --> 00:03:04,159
並且它只允許您一次只使用一個 GPU

138
00:03:00,000 --> 00:03:04,159
 and it only allows you to work with one gpu at a time

139
00:03:04,159 --> 00:03:07,040
您不能在多個 Colab 帳戶上運行

140
00:03:04,159 --> 00:03:07,040
 you cannot run on multiple colab accounts

141
00:03:07,040 --> 00:03:08,640
你知道使用多個 GPU

142
00:03:07,040 --> 00:03:08,640
 you know with multiple gpus

143
00:03:08,640 --> 00:03:09,920
所以

144
00:03:08,640 --> 00:03:09,920
 so

145
00:03:09,920 --> 00:03:11,599
要注意這點

146
00:03:09,920 --> 00:03:11,599
 be aware of that

147
00:03:11,599 --> 00:03:16,000
和你本地電腦一樣，如果你的 GPU 已經忙於處理

148
00:03:11,599 --> 00:03:16,000
 and same with your local computer right if your gpu is already busy doing

149
00:03:16,000 --> 00:03:18,879
訓練模型不像你可以，你可以

150
00:03:16,000 --> 00:03:18,879
 training a model it's not like you can you can

151
00:03:18,879 --> 00:03:24,159
編程它去做其他任務，那你的效率就會大幅下降，基本上是類似的

152
00:03:18,879 --> 00:03:24,159
 program it to do other tasks then your efficiency goes down pretty much similar

153
00:03:24,159 --> 00:03:24,560
好的

154
00:03:24,159 --> 00:03:24,560
 okay

155
00:03:24,560 --> 00:03:25,280
現在

156
00:03:24,560 --> 00:03:25,280
 so now

157
00:03:25,280 --> 00:03:25,920
什麼數據

158
00:03:25,280 --> 00:03:25,920
 what data

159
00:03:25,920 --> 00:03:27,200
我將要使用

160
00:03:25,920 --> 00:03:27,200
 am i going to work with

161
00:03:27,200 --> 00:03:28,879
這裡的數據

162
00:03:27,200 --> 00:03:28,879
 this is the data here

163
00:03:28,879 --> 00:03:31,120
請點擊這個鏈接，我會分享這個

164
00:03:28,879 --> 00:03:31,120
 go ahead and click on this link i'll share this

165
00:03:31,120 --> 00:03:35,599
這會帶你到一個看起來像這樣的頁面，這是電子顯微鏡數據集

166
00:03:31,120 --> 00:03:35,599
 and it takes you to a page that looks like this this is electron microscopy data set

167
00:03:35,599 --> 00:03:39,680
他們擁有原始圖像

168
00:03:35,599 --> 00:03:39,680
 and they have both the you know the original images

169
00:03:39,680 --> 00:03:41,120
以及標籤

170
00:03:39,680 --> 00:03:41,120
 and also the labels

171
00:03:41,120 --> 00:03:44,720
然後繼續下載它 下載

172
00:03:41,120 --> 00:03:44,720
 and go ahead and download it download

173
00:03:44,720 --> 00:03:46,879
是的，每一個這些子卷

174
00:03:44,720 --> 00:03:46,879
 yeah each of these sub volumes

175
00:03:46,879 --> 00:03:49,920
而我只處理第一個

176
00:03:46,879 --> 00:03:49,920
 and i'm only working with the first one

177
00:03:49,920 --> 00:03:52,000
並且我拍攝了這些圖片

178
00:03:49,920 --> 00:03:52,000
 and i took these images

179
00:03:52,000 --> 00:03:53,519
和面具

180
00:03:52,000 --> 00:03:53,519
 and masks

181
00:03:53,519 --> 00:03:57,760
我已經將它們裁剪成

182
00:03:53,519 --> 00:03:57,760
 and i have cropped them into

183
00:03:57,760 --> 00:03:58,560
成為

184
00:03:57,760 --> 00:03:58,560
 into

185
00:03:58,560 --> 00:04:00,480
讓我們看看我在這裡做了什麼

186
00:03:58,560 --> 00:04:00,480
 let's see what am i doing here

187
00:04:00,480 --> 00:04:02,799
轉換為 256 x 256 的大小。

188
00:04:00,480 --> 00:04:02,799
 into size of 256 by 256.

189
00:04:02,799 --> 00:04:07,920
我實際上將這些圖片裁剪成 256x256

190
00:04:02,799 --> 00:04:07,920
 i actually cropped these images into 256x256

191
00:04:07,920 --> 00:04:12,000
如果你問我怎麼做的，我一直在講解 patchify

192
00:04:07,920 --> 00:04:12,000
 if you ask me how did i do that i've been talking about patchify

193
00:04:12,000 --> 00:04:14,000
和 unpatchify 已經有一段時間了，對吧

194
00:04:12,000 --> 00:04:14,000
 and unpatchify for a while right

195
00:04:14,000 --> 00:04:16,720
我的意思是使用名為 patchify 的函式庫

196
00:04:14,000 --> 00:04:16,720
 i mean use the library called patchify

197
00:04:16,720 --> 00:04:19,680
這可以實際從你的圖像中生成區塊

198
00:04:16,720 --> 00:04:19,680
 that can actually generate patches out of your images

199
00:04:19,680 --> 00:04:23,680
然後只需寫幾行代碼將這些圖像保存為 JPEG 格式

200
00:04:19,680 --> 00:04:23,680
 and then just write a couple of lines to save those images as jpegs

201
00:04:23,680 --> 00:04:26,160
將提示或提示保存到本地磁碟

202
00:04:23,680 --> 00:04:26,160
 or tips onto your local drive

203
00:04:26,160 --> 00:04:26,639
如果你

204
00:04:26,160 --> 00:04:26,639
 if you

205
00:04:26,639 --> 00:04:27,919
如果你想，你可以編寫那段代碼

206
00:04:26,639 --> 00:04:27,919
 if you want you can code that

207
00:04:27,919 --> 00:04:32,880
我的意思是這並不難對吧？我的意思是你加載一個任意大小的 numpy 陣列

208
00:04:27,919 --> 00:04:32,880
 i mean that's not difficult right i mean you load a numpy array of whatever size

209
00:04:32,880 --> 00:04:37,040
然後你說我想把這個分成 256 x 256 的區塊。

210
00:04:32,880 --> 00:04:37,040
 and then you say i want to divide this into 256 by 256.

211
00:04:37,040 --> 00:04:41,199
所以繼續，每次在 x 和 y 方向上取 256。

212
00:04:37,040 --> 00:04:41,199
 so go ahead and get 256 at a time in x and y

213
00:04:41,199 --> 00:04:44,880
然後就保存到你的硬碟，別忘了完全按照步驟做。

214
00:04:41,199 --> 00:04:44,880
 and then just save it to your drive don't forget to do exactly

215
00:04:44,880 --> 00:04:46,800
與你的遮罩相同

216
00:04:44,880 --> 00:04:46,800
 the same to your masks

217
00:04:46,800 --> 00:04:48,160
因此你的輸入影像

218
00:04:46,800 --> 00:04:48,160
 so your input images

219
00:04:48,160 --> 00:04:51,919
和遮罩明顯地匹配在一起，你不希望出現不匹配的情況

220
00:04:48,160 --> 00:04:51,919
 and masks kind of match together obviously you don't want a mismatch

221
00:04:51,919 --> 00:04:52,560
好的

222
00:04:51,919 --> 00:04:52,560
 yeah

223
00:04:52,560 --> 00:04:55,440
所以我

224
00:04:52,560 --> 00:04:55,440
 so i

225
00:04:55,440 --> 00:04:57,520
我相信在這種情況下我使用了 patchify

226
00:04:55,440 --> 00:04:57,520
 believe in this case i used patchify

227
00:04:57,520 --> 00:05:00,479
然後我說，好吧，這是我的大圖像，進行切片

228
00:04:57,520 --> 00:05:00,479
 and i said okay this is my large image patchify it

229
00:05:00,479 --> 00:05:04,639
所以如果我的圖像是 7，我不知道 512 乘 512，那麼

230
00:05:00,479 --> 00:05:04,639
 so if my image is 7 i don't know 512 by 512 then

231
00:05:04,639 --> 00:05:07,280
如果我將其切割成 256，那麼我將得到

232
00:05:04,639 --> 00:05:07,280
 if i chop it into 256 then i'll get

233
00:05:07,280 --> 00:05:11,919
2 乘 2 乘 256 乘 256，對吧

234
00:05:07,280 --> 00:05:11,919
 2 by 2 by 256 by 256 right

235
00:05:11,919 --> 00:05:13,280
希望這樣能說明清楚

236
00:05:11,919 --> 00:05:13,280
 i hope that makes sense

237
00:05:13,280 --> 00:05:13,600
好的

238
00:05:13,280 --> 00:05:13,600
 okay

239
00:05:13,600 --> 00:05:17,440
所以 5 12 在 x 5 12 在 y，所以是 2 乘 2

240
00:05:13,600 --> 00:05:17,440
 so 5 12 in x 5 12 in y so it's 2 by 2

241
00:05:17,440 --> 00:05:19,280
我保存了這四個

242
00:05:17,440 --> 00:05:19,280
 and i saved these four

243
00:05:19,280 --> 00:05:23,120
將我的 5 12 乘以 5 12 的四個補丁轉移到我的本地驅動器上

244
00:05:19,280 --> 00:05:23,120
 four patches from my 5 12 by 5 12 on to my local drive

245
00:05:23,120 --> 00:05:24,880
然後我對我的面具做了相同的操作

246
00:05:23,120 --> 00:05:24,880
 and then i did the same for my masks

247
00:05:24,880 --> 00:05:28,960
所以這就是我如何從這裡獲得我的數據集

248
00:05:24,880 --> 00:05:28,960
 so that's how i got my data set from here

249
00:05:28,960 --> 00:05:33,520
現在我有了我的 256 x 256，讓我們繼續

250
00:05:28,960 --> 00:05:33,520
 now that i have my 256 by 256 let's go ahead

251
00:05:33,520 --> 00:05:34,560
並開始工作

252
00:05:33,520 --> 00:05:34,560
 and start working

253
00:05:34,560 --> 00:05:39,199
好的，讓我們導入所需的庫

254
00:05:34,560 --> 00:05:39,199
 okay let's import the required libraries

255
00:05:39,199 --> 00:05:41,840
我不認為我在使用 normalize

256
00:05:39,199 --> 00:05:41,840
 i'm i don't think i'm using normalize

257
00:05:41,840 --> 00:05:43,680
有些這些你會發現

258
00:05:41,840 --> 00:05:43,680
 some of these i you'll realize

259
00:05:43,680 --> 00:05:44,479
我並沒有使用

260
00:05:43,680 --> 00:05:44,479
 that i'm not using

261
00:05:44,479 --> 00:05:47,199
它們，但它們是剩下的

262
00:05:44,479 --> 00:05:47,199
 them but they are left over from

263
00:05:47,199 --> 00:05:49,280
從我之前的實驗中

264
00:05:47,199 --> 00:05:49,280
 from my earlier experiments

265
00:05:49,280 --> 00:05:52,560
但我傾向於保留它們，以防你想使用 normalize

266
00:05:49,280 --> 00:05:52,560
 but i tend to leave them in in case you want to use normalize

267
00:05:52,560 --> 00:05:54,800
在你知道如何縮放你的影像時

268
00:05:52,560 --> 00:05:54,800
 in you know to scale your images

269
00:05:54,800 --> 00:05:56,319
嗯，我就這樣留著吧

270
00:05:54,800 --> 00:05:56,319
 yeah so i'll just leave that

271
00:05:56,319 --> 00:06:00,400
好的，讓我們來檢查這些檔案 opencv

272
00:05:56,319 --> 00:06:00,400
 okay os to walk through the files opencv

273
00:06:00,400 --> 00:06:01,759
使用 pillow 來調整圖像大小

274
00:06:00,400 --> 00:06:01,759
 pillow to resize images

275
00:06:01,759 --> 00:06:03,440
如果你需要

276
00:06:01,759 --> 00:06:03,440
 if you have to

277
00:06:03,440 --> 00:06:05,520
numpy 陣列

278
00:06:03,440 --> 00:06:05,520
 numpy array

279
00:06:05,520 --> 00:06:10,639
顯然這就是我們正在使用的 piplot，我也留了這個 min max scaler

280
00:06:05,520 --> 00:06:10,639
 obviously is what we are working with piplot i also left this min max scalar

281
00:06:10,639 --> 00:06:14,000
如果你想用這個來縮放圖像而不是標準化

282
00:06:10,639 --> 00:06:14,000
 if you want to use this to scale images instead of normalize

283
00:06:14,000 --> 00:06:14,960
這取決於你

284
00:06:14,000 --> 00:06:14,960
 it's up to you

285
00:06:14,960 --> 00:06:17,280
而從優化器中我正在導入 atoms

286
00:06:14,960 --> 00:06:17,280
 and from optimizers i'm importing atoms

287
00:06:17,280 --> 00:06:19,520
所以我們可以把它當作優化器來使用

288
00:06:17,280 --> 00:06:19,520
 so we can use that as an optimizer

289
00:06:19,520 --> 00:06:20,800
我正在使用 glob

290
00:06:19,520 --> 00:06:20,800
 and i'm using glob

291
00:06:20,800 --> 00:06:22,319
這樣我們就可以遍歷檔案

292
00:06:20,800 --> 00:06:22,319
 so we can walk through the files

293
00:06:22,319 --> 00:06:25,840
好的，請原諒我

294
00:06:22,319 --> 00:06:25,840
 okay excuse me

295
00:06:25,840 --> 00:06:28,560
現在我正在定義我的影像和遮罩目錄

296
00:06:25,840 --> 00:06:28,560
 now i'm defining my image and mask directory

297
00:06:28,560 --> 00:06:33,039
我已經，讓我檢查，我已經連接了我的驅動器，就在那裡，Google Drive

298
00:06:28,560 --> 00:06:33,039
 i have already let me check i have already connected my drive right there google drive

299
00:06:33,039 --> 00:06:36,560
然後我所做的就是去我的數據所在的地方

300
00:06:33,039 --> 00:06:36,560
 and all i did is go to my data wherever the data is

301
00:06:36,560 --> 00:06:37,440
然後只需

302
00:06:36,560 --> 00:06:37,440
 and then just

303
00:06:37,440 --> 00:06:40,400
然後只需複製此路徑

304
00:06:37,440 --> 00:06:40,400
 and then just get this copy path

305
00:06:40,400 --> 00:06:41,360
是的，這正是

306
00:06:40,400 --> 00:06:41,360
 yeah that's exactly

307
00:06:41,360 --> 00:06:42,560
我所做的

308
00:06:41,360 --> 00:06:42,560
 what i've done

309
00:06:42,560 --> 00:06:45,840
這是我的圖片路徑，這是我的遮罩路徑

310
00:06:42,560 --> 00:06:45,840
 and this is the path to my images this is the path to my masks

311
00:06:45,840 --> 00:06:49,199
所以這只是定義目錄，接下來我會定義大小

312
00:06:45,840 --> 00:06:49,199
 so this is just defining the directories next i'll define the size

313
00:06:49,199 --> 00:06:50,240
和圖片數量

314
00:06:49,199 --> 00:06:50,240
 and number of images

315
00:06:50,240 --> 00:06:52,479
我想合作的是因為這次我分開

316
00:06:50,240 --> 00:06:52,479
 i'd like to work with because this once i divide

317
00:06:52,479 --> 00:06:56,960
我想我最終得到了大約 1600 張圖片

318
00:06:52,479 --> 00:06:56,960
 this i think i ended up with about 1600 images

319
00:06:56,960 --> 00:06:59,360
然後訓練變得有點慢

320
00:06:56,960 --> 00:06:59,360
 and then the training gets a bit slow

321
00:06:59,360 --> 00:07:04,000
當然，我建議你使用全部 1600 張圖片。就我而言，我只

322
00:06:59,360 --> 00:07:04,000
 of course i recommend you to use all 1600 images in my case i just

323
00:07:04,000 --> 00:07:06,160
選擇使用，我不知道，500 張圖片

324
00:07:04,000 --> 00:07:06,160
 chose to use i don't know 500 images

325
00:07:06,160 --> 00:07:06,960
或 1000 張

326
00:07:06,160 --> 00:07:06,960
 or thousand

327
00:07:06,960 --> 00:07:08,560
然後我停在了一千

328
00:07:06,960 --> 00:07:08,560
 and i stopped at thousand

329
00:07:08,560 --> 00:07:10,319
因為我得到了不錯的結果

330
00:07:08,560 --> 00:07:10,319
 because i was getting decent results

331
00:07:10,319 --> 00:07:13,440
所以我們繼續，這些只是變數對吧

332
00:07:10,319 --> 00:07:13,440
 so let's go ahead and these are just variables right

333
00:07:13,440 --> 00:07:15,199
所以現在我們需要定義

334
00:07:13,440 --> 00:07:15,199
 so now we need to define

335
00:07:15,199 --> 00:07:16,560
我的圖像名稱

336
00:07:15,199 --> 00:07:16,560
 my image names

337
00:07:16,560 --> 00:07:18,960
你如何定義你的圖像名稱

338
00:07:16,560 --> 00:07:18,960
 how do you define your image names

339
00:07:18,960 --> 00:07:21,280
好吧，首先為什麼我

340
00:07:18,960 --> 00:07:21,280
 well why first of all why am i

341
00:07:21,280 --> 00:07:25,199
定義圖像名稱，而不僅僅是從磁碟中加載圖像

342
00:07:21,280 --> 00:07:25,199
 defining image names and not just loading the images from the disk

343
00:07:25,199 --> 00:07:32,880
問題在於這是另一個重要的建議

344
00:07:25,199 --> 00:07:32,880
 the problem is this is again another important piece of advice

345
00:07:32,880 --> 00:07:35,919
在您花費大量時間加載圖像之前

346
00:07:32,880 --> 00:07:35,919
 before you spend a lot of time when you load the images

347
00:07:35,919 --> 00:07:40,000
就直接一個接一個地載入，就像寫一個 for 迴圈一樣

348
00:07:35,919 --> 00:07:40,000
 just go ahead and load one after the other like just write a for loop

349
00:07:40,000 --> 00:07:40,479
好的

350
00:07:40,000 --> 00:07:40,479
 yeah

351
00:07:40,479 --> 00:07:44,240
然後從特定磁碟中一個接一個地加載

352
00:07:40,479 --> 00:07:44,240
 and then load one after the other from a specific drive

353
00:07:44,240 --> 00:07:47,680
問題是，在 Windows 上它可能運作良好

354
00:07:44,240 --> 00:07:47,680
 the problem is on windows it may work fine

355
00:07:47,680 --> 00:07:50,639
因為 Windows 可能會根據這些數字進行整理

356
00:07:47,680 --> 00:07:50,639
 because windows probably organizes these based on the number

357
00:07:50,639 --> 00:07:51,360
或其他什麼

358
00:07:50,639 --> 00:07:51,360
 or something

359
00:07:51,360 --> 00:07:54,240
但在 Linux 上肯定會是這樣

360
00:07:51,360 --> 00:07:54,240
 but on linux like definitely here

361
00:07:54,240 --> 00:07:57,520
如果你這麼做，它很可能

362
00:07:54,240 --> 00:07:57,520
 if you do that it's it's probably

363
00:07:57,520 --> 00:08:03,199
你的圖片會根據它被加入到硬碟的時間來排序

364
00:07:57,520 --> 00:08:03,199
 your images are sorted based on the time it got added to the drive

365
00:08:03,199 --> 00:08:06,000
然後當你載入你的圖片時

366
00:08:03,199 --> 00:08:06,000
 then when you load your images

367
00:08:06,000 --> 00:08:08,319
而且你的遮罩會對不上

368
00:08:06,000 --> 00:08:08,319
 and your masks they won't line up

369
00:08:08,319 --> 00:08:11,840
因為當你加載第一張圖片為 500 多時

370
00:08:08,319 --> 00:08:11,840
 because when you load the first image as 500 something

371
00:08:11,840 --> 00:08:14,879
但是第一個遮罩有 100 多，他們對不齊

372
00:08:11,840 --> 00:08:14,879
 but first mask has 100 something they don't line up

373
00:08:14,879 --> 00:08:17,440
所以我們需要根據名稱對圖片進行排序

374
00:08:14,879 --> 00:08:17,440
 so we need to sort images based on the names

375
00:08:17,440 --> 00:08:20,560
或任何我們需要排序的標準

376
00:08:17,440 --> 00:08:20,560
 or whatever criteria we need to sort them

377
00:08:20,560 --> 00:08:21,360
兩張圖片

378
00:08:20,560 --> 00:08:21,360
 both images

379
00:08:21,360 --> 00:08:23,039
和面具，假設你的面具

380
00:08:21,360 --> 00:08:23,039
 and masks assuming your masks

381
00:08:23,039 --> 00:08:26,960
和圖片有類似的名稱，例如如果我的圖片是 image 121

382
00:08:23,039 --> 00:08:26,960
 and images have similar names like if my image is image 121

383
00:08:26,960 --> 00:08:32,000
我的面具將會是 mask 121，對吧？這是處理你的圖片和面具的最佳方式

384
00:08:26,960 --> 00:08:32,000
 my mask will be mask 121 right that's the best way to do your images

385
00:08:32,000 --> 00:08:34,399
和面具，我希望這樣解釋清楚了

386
00:08:32,000 --> 00:08:34,399
 and masks i hope i hope this makes sense

387
00:08:34,399 --> 00:08:38,320
所以要整理我的圖片

388
00:08:34,399 --> 00:08:38,320
 so to sort my images

389
00:08:38,320 --> 00:08:40,880
首先讓我獲取圖片的名稱

390
00:08:38,320 --> 00:08:40,880
 first let me get the names of the images

391
00:08:40,880 --> 00:08:41,360
然後

392
00:08:40,880 --> 00:08:41,360
 and then

393
00:08:41,360 --> 00:08:42,159
我會進行排序

394
00:08:41,360 --> 00:08:42,159
 i'll sort

395
00:08:42,159 --> 00:08:42,640
好的

396
00:08:42,159 --> 00:08:42,640
 okay

397
00:08:42,640 --> 00:08:45,360
所以首先我們來查看一下

398
00:08:42,640 --> 00:08:45,360
 so let's check out first of all

399
00:08:45,360 --> 00:08:49,360
glob dot glob 這會顯示檔案的名稱

400
00:08:45,360 --> 00:08:49,360
 glob dot glob it gets you the names file names of what

401
00:08:49,360 --> 00:08:51,120
所有具有 TIFF 擴展名的文件

402
00:08:49,360 --> 00:08:51,120
 everything that has an extension of tiff

403
00:08:51,120 --> 00:08:52,720
所以讓我們繼續載入它

404
00:08:51,120 --> 00:08:52,720
 so let's go ahead and load that

405
00:08:52,720 --> 00:08:55,760
並列印名稱，讓我們繼續這樣做

406
00:08:52,720 --> 00:08:55,760
 and print the names let's go ahead and do that

407
00:08:55,760 --> 00:08:59,600
所以它正在載入，正在讀取所有檔案以獲取名稱

408
00:08:55,760 --> 00:08:59,600
 so it's loading it's reading all the files getting the names

409
00:08:59,600 --> 00:09:02,320
只是列印名稱

410
00:08:59,600 --> 00:09:02,320
 and just printing the names

411
00:09:02,320 --> 00:09:03,680
我只是想給你看看

412
00:09:02,320 --> 00:09:03,680
 i just want to show you

413
00:09:03,680 --> 00:09:10,640
這些名稱如何是隨機的，你看我的第一張圖片是 602.tiff

414
00:09:03,680 --> 00:09:10,640
 how these names can be random you see my first image is 602.tiff

415
00:09:10,640 --> 00:09:14,320
我的下一張圖片如果我往右移動到那裡

416
00:09:10,640 --> 00:09:14,320
 my next image if i move right there

417
00:09:14,320 --> 00:09:15,760
是 601.f

418
00:09:14,320 --> 00:09:15,760
 is 601.f

419
00:09:15,760 --> 00:09:17,279
然後是 600.f

420
00:09:15,760 --> 00:09:17,279
 and then 600.f

421
00:09:17,279 --> 00:09:19,519
所有 fsn604.tiff

422
00:09:17,279 --> 00:09:19,519
 all fsn604.tiff

423
00:09:19,519 --> 00:09:20,399
如果我離開

424
00:09:19,519 --> 00:09:20,399
 and if i go

425
00:09:20,399 --> 00:09:23,600
這不是，這不是在六四十八的順序，如果我來這裡

426
00:09:20,399 --> 00:09:23,600
 it's not it's not in an order six forty eight if i go here

427
00:09:23,600 --> 00:09:26,640
我有一一六七一一七二

428
00:09:23,600 --> 00:09:26,640
 i have one one six seven one one seven two

429
00:09:26,640 --> 00:09:29,040
完全不同的一些隨機順序

430
00:09:26,640 --> 00:09:29,040
 completely different some random order

431
00:09:29,040 --> 00:09:30,560
所以我想要這些被排序

432
00:09:29,040 --> 00:09:30,560
 so i want these to be sorted

433
00:09:30,560 --> 00:09:31,760
我該怎麼做

434
00:09:30,560 --> 00:09:31,760
 how do i do that

435
00:09:31,760 --> 00:09:33,680
所以我拿我的圖像名稱

436
00:09:31,760 --> 00:09:33,680
 so i take my image names

437
00:09:33,680 --> 00:09:35,680
然後我只是做點排序

438
00:09:33,680 --> 00:09:35,680
 and i just do dot sort

439
00:09:35,680 --> 00:09:37,200
現在我們來打印它

440
00:09:35,680 --> 00:09:37,200
 now let's go ahead and print it

441
00:09:37,200 --> 00:09:40,080
你會看到圖像 0

442
00:09:37,200 --> 00:09:40,080
 and you see image 0

443
00:09:40,080 --> 00:09:42,959
希望它應該是圖像 1 圖像 2

444
00:09:40,080 --> 00:09:42,959
 hopefully it should be image 1 image 2

445
00:09:42,959 --> 00:09:46,399
所以我的意思是 1 之後是從 10 開始的

446
00:09:42,959 --> 00:09:46,399
 so i mean after 1 it starts with 10 right there

447
00:09:46,399 --> 00:09:48,000
然後是 11

448
00:09:46,399 --> 00:09:48,000
 and then it's 11

449
00:09:48,000 --> 00:09:50,399
或 100

450
00:09:48,000 --> 00:09:50,399
 or 100

451
00:09:50,399 --> 00:09:54,320
一千，從這個開始，很明顯首先查看這個

452
00:09:50,399 --> 00:09:54,320
 one thousand it's starting with it's obviously looking at this one first

453
00:09:54,320 --> 00:09:54,800
好的

454
00:09:54,320 --> 00:09:54,800
 yeah

455
00:09:54,800 --> 00:09:57,120
然後它會到達兩個，我打賭

456
00:09:54,800 --> 00:09:57,120
 and then it goes to two i bet

457
00:09:57,120 --> 00:09:57,760
所以

458
00:09:57,120 --> 00:09:57,760
 so

459
00:09:57,760 --> 00:10:00,560
然後一千二，一千三，一千四

460
00:09:57,760 --> 00:10:00,560
 and then one thousand two one thousand three one thousand four

461
00:10:00,560 --> 00:10:01,839
然後它會跳過

462
00:10:00,560 --> 00:10:01,839
 so on and then it jumps

463
00:10:01,839 --> 00:10:06,079
所以這有一個特定的順序，這就是我想說的全部

464
00:10:01,839 --> 00:10:06,079
 so there is a specific order to this that's it that's all i'm trying to say

465
00:10:06,079 --> 00:10:12,240
所以這些圖像中，我只會取前 1000 張，我有 1600 張

466
00:10:06,079 --> 00:10:12,240
 so of these images i'm going to take only the first 1000 images i have 1600

467
00:10:12,240 --> 00:10:12,640
或其他什麼

468
00:10:12,240 --> 00:10:12,640
 or something

469
00:10:12,640 --> 00:10:15,519
所以讓我再拍攝 1,000 張圖片，為什麼

470
00:10:12,640 --> 00:10:15,519
 so let me just take 1 000 images again why

471
00:10:15,519 --> 00:10:19,680
因為我希望我的訓練能稍微快一點，這是可選的

472
00:10:15,519 --> 00:10:19,680
 because i want my training to be a bit faster this is optional

473
00:10:19,680 --> 00:10:21,360
好的，一旦我做到這點

474
00:10:19,680 --> 00:10:21,360
 okay once i do that

475
00:10:21,360 --> 00:10:24,000
現在是閱讀圖像的時候

476
00:10:21,360 --> 00:10:24,000
 now is the time to read the images

477
00:10:24,000 --> 00:10:28,320
到目前為止，我有影像名稱，但在陣列中沒有影像

478
00:10:24,000 --> 00:10:28,320
 so far i have image names i don't have images in the arrays

479
00:10:28,320 --> 00:10:33,360
所以目前我要讀取的方式，你也可以使用數據生成器

480
00:10:28,320 --> 00:10:33,360
 so the way i'm going to read at this point you can also use a data generator

481
00:10:33,360 --> 00:10:37,440
所以你會批次讀取影像，我們將來會做一個相關的視頻

482
00:10:33,360 --> 00:10:37,440
 so you read images in batches we'll do a video on that in future

483
00:10:37,440 --> 00:10:40,560
但現在我們將所有一千張圖像載入記憶體中

484
00:10:37,440 --> 00:10:40,560
 but for now we are loading all thousand images into the memory

485
00:10:40,560 --> 00:10:42,000
然後進行訓練

486
00:10:40,560 --> 00:10:42,000
 and then performing the training

487
00:10:42,000 --> 00:10:42,399
好的

488
00:10:42,000 --> 00:10:42,399
 okay

489
00:10:42,399 --> 00:10:45,519
我們怎麼做到這一點

490
00:10:42,399 --> 00:10:45,519
 how do we do that this is a a

491
00:10:45,519 --> 00:10:52,480
對於列表推導式，就像你知道的，對於這些圖像名稱子集中的每個圖像

492
00:10:45,519 --> 00:10:52,480
 for list comprehension like you know for each image in these image name subset

493
00:10:52,480 --> 00:10:58,000
就在那裡，對於這些圖像中的每一個，繼續使用 cv2.imread

494
00:10:52,480 --> 00:10:58,000
 right there for each of these images go ahead and do cv2.imread

495
00:10:58,000 --> 00:10:59,680
以及每個影像

496
00:10:58,000 --> 00:10:59,680
 and each image

497
00:10:59,680 --> 00:11:02,800
然後將其讀取為一個正確的灰階影像

498
00:10:59,680 --> 00:11:02,800
 and then read that as a grayscale image that's exactly

499
00:11:02,800 --> 00:11:05,200
這行正在做的事情，這會非常慢

500
00:11:02,800 --> 00:11:05,200
 what this line is doing this will be very slow

501
00:11:05,200 --> 00:11:07,920
因為現在它正在讀取 1000 張圖像

502
00:11:05,200 --> 00:11:07,920
 because now it's reading 1000 images

503
00:11:07,920 --> 00:11:08,720
好的

504
00:11:07,920 --> 00:11:08,720
 okay

505
00:11:08,720 --> 00:11:10,800
當它在執行這個操作時，讓我們繼續前進

506
00:11:08,720 --> 00:11:10,800
 and while it's doing that let's go ahead

507
00:11:10,800 --> 00:11:16,640
並查看面具部分，我對面具做了完全相同的操作，我正在讀取

508
00:11:10,800 --> 00:11:16,640
 and look at the masks part i'm doing exactly the same for masks i'm reading

509
00:11:16,640 --> 00:11:18,399
所有的遮罩名稱

510
00:11:16,640 --> 00:11:18,399
 all the mask names

511
00:11:18,399 --> 00:11:19,839
你看到 glob 點 glob

512
00:11:18,399 --> 00:11:19,839
 you see glob dot glob

513
00:11:19,839 --> 00:11:21,440
然後我正在整理它們

514
00:11:19,839 --> 00:11:21,440
 and then i'm sorting them

515
00:11:21,440 --> 00:11:23,760
這一步非常重要

516
00:11:21,440 --> 00:11:23,760
 and this step is very important

517
00:11:23,760 --> 00:11:25,360
如果你想要這些影像

518
00:11:23,760 --> 00:11:25,360
 if you want these images

519
00:11:25,360 --> 00:11:28,160
和面具以完全相同的方式進行排序

520
00:11:25,360 --> 00:11:28,160
 and masks to be sorted exactly the same way

521
00:11:28,160 --> 00:11:29,040
所以你的影像

522
00:11:28,160 --> 00:11:29,040
 so your images

523
00:11:29,040 --> 00:11:31,680
和遮罩會排列整齊

524
00:11:29,040 --> 00:11:31,680
 and masks will be lined up

525
00:11:31,680 --> 00:11:36,800
好的，再說一次，當事情不如預期時，你會失去理智

526
00:11:31,680 --> 00:11:36,800
 okay again you'll lose your mind when things don't work out that way

527
00:11:36,800 --> 00:11:40,480
而且要花很長時間才能弄清楚到底為什麼

528
00:11:36,800 --> 00:11:40,480
 and it takes forever to figure out exactly why

529
00:11:40,480 --> 00:11:41,120
好的

530
00:11:40,480 --> 00:11:41,120
 okay

531
00:11:41,120 --> 00:11:46,399
然後來到面罩名稱零到一千，這就是我們已經完成的

532
00:11:41,120 --> 00:11:46,399
 and then comes mask name zero to one thousand that's what we have already done

533
00:11:46,399 --> 00:11:48,240
然後是 cb2.imread

534
00:11:46,399 --> 00:11:48,240
 and then comes cb2.imread

535
00:11:48,240 --> 00:11:54,320
所以這些步驟與我對我的圖像所做的完全相同，對吧

536
00:11:48,240 --> 00:11:54,320
 so these steps are identical to what i have done with my images right

537
00:11:54,320 --> 00:11:56,320
除非我把所有東西都放在一個區塊中

538
00:11:54,320 --> 00:11:56,320
 except i just put everything in one block

539
00:11:56,320 --> 00:11:58,480
所以一旦圖像變紅

540
00:11:56,320 --> 00:11:58,480
 so once the images are red

541
00:11:58,480 --> 00:12:00,399
這將是一個列表

542
00:11:58,480 --> 00:12:00,399
 this will be a list

543
00:12:00,399 --> 00:12:03,760
這些是影像的列表，我將它們轉換為 numpy 陣列

544
00:12:00,399 --> 00:12:03,760
 right these are list of images i convert them to numpy array

545
00:12:03,760 --> 00:12:05,519
然後我擴展維度

546
00:12:03,760 --> 00:12:05,519
 and then i expand the dimensions

547
00:12:05,519 --> 00:12:08,399
使它們處於正確的格式

548
00:12:05,519 --> 00:12:08,399
 so they are in the right format

549
00:12:08,399 --> 00:12:10,720
用於我的神經網絡

550
00:12:08,399 --> 00:12:10,720
 for my neural network

551
00:12:10,720 --> 00:12:11,120
好的

552
00:12:10,720 --> 00:12:11,120
 okay

553
00:12:11,120 --> 00:12:14,000
所以這就是我們在這裡嘗試做的事情

554
00:12:11,120 --> 00:12:14,000
 so that's that's what we are trying to do here

555
00:12:14,000 --> 00:12:16,399
我的遮罩也是一樣

556
00:12:14,000 --> 00:12:16,399
 and same with my same with my masks

557
00:12:16,399 --> 00:12:19,839
然後我將在這裡列印出形狀

558
00:12:16,399 --> 00:12:19,839
 and then i'm going to print out the shapes right here

559
00:12:19,839 --> 00:12:20,480
所以

560
00:12:19,839 --> 00:12:20,480
 so

561
00:12:20,480 --> 00:12:24,240
我會再說一次，我不確定這還要花多久時間

562
00:12:20,480 --> 00:12:24,240
 what i'll do is again i'm not sure how much longer this is going to take

563
00:12:24,240 --> 00:12:27,440
那我現在暫停這段影片

564
00:12:24,240 --> 00:12:27,440
 so let me pause this video right now

565
00:12:27,440 --> 00:12:32,079
等我們準備好影像後再繼續

566
00:12:27,440 --> 00:12:32,079
 and continue as soon as we have the images ready

567
00:12:32,079 --> 00:12:34,399
好的，已經過了三到四分鐘

568
00:12:32,079 --> 00:12:34,399
 well it's been three to four minutes

569
00:12:34,399 --> 00:12:35,920
這個還在載入中

570
00:12:34,399 --> 00:12:35,920
 and this thing is still loading

571
00:12:35,920 --> 00:12:39,200
所以我們來停止它，因為我已經訓練好了模型

572
00:12:35,920 --> 00:12:39,200
 so let's go ahead and stop it because i've already trained the model

573
00:12:39,200 --> 00:12:41,839
所以讓我把這個改成 100 張圖片

574
00:12:39,200 --> 00:12:41,839
 so let me change this to 100 images

575
00:12:41,839 --> 00:12:43,680
所以我們可以測試模型對吧

576
00:12:41,839 --> 00:12:43,680
 so we can test the model right

577
00:12:43,680 --> 00:12:46,079
所以我們先把這個改成 100 張圖片

578
00:12:43,680 --> 00:12:46,079
 so let's go ahead and change that to 100 images

579
00:12:46,079 --> 00:12:46,560
和

580
00:12:46,079 --> 00:12:46,560
 and

581
00:12:46,560 --> 00:12:48,560
現在我們來讀取這 100 張圖片

582
00:12:46,560 --> 00:12:48,560
 now let's read these 100 images

583
00:12:48,560 --> 00:12:53,600
我希望這將比閱讀 1000 張圖片快得多

584
00:12:48,560 --> 00:12:53,600
 and i hope this will be much much faster than reading 1000 images

585
00:12:53,600 --> 00:12:56,160
所以希望它可以在幾秒鐘內完成

586
00:12:53,600 --> 00:12:56,160
 so hopefully it should be done in a few seconds

587
00:12:56,160 --> 00:12:57,680
然後我們可以繼續

588
00:12:56,160 --> 00:12:57,680
 and we can continue

589
00:12:57,680 --> 00:13:01,519
因為我們需要一些測試用的圖片

590
00:12:57,680 --> 00:13:01,519
 because we need some images for testing

591
00:13:01,519 --> 00:13:01,839
好的

592
00:13:01,519 --> 00:13:01,839
 okay

593
00:13:01,839 --> 00:13:07,839
所以我已經用 1000 張圖片訓練了一個模型

594
00:13:01,839 --> 00:13:07,839
 so i've already trained a model using 1000 images

595
00:13:08,000 --> 00:13:08,480
好的

596
00:13:08,000 --> 00:13:08,480
 okay

597
00:13:08,480 --> 00:13:08,959
所以

598
00:13:08,480 --> 00:13:08,959
 so

599
00:13:08,959 --> 00:13:11,920
現在讓我們將那些轉換為 numpy 區域

600
00:13:08,959 --> 00:13:11,920
 now let's convert those into numpy areas

601
00:13:11,920 --> 00:13:15,920
否則這些圖像只是一堆列表對吧

602
00:13:11,920 --> 00:13:15,920
 because otherwise these images are just a bunch a list right

603
00:13:15,920 --> 00:13:17,200
所以讓我們轉換它

604
00:13:15,920 --> 00:13:17,200
 so let's convert that

605
00:13:17,200 --> 00:13:18,639
然後擴展尺寸

606
00:13:17,200 --> 00:13:18,639
 and then expand the dimensions

607
00:13:18,639 --> 00:13:20,880
現在讓我們對我們的面具做完全相同的操作

608
00:13:18,639 --> 00:13:20,880
 now let's do exactly the same for our masks

609
00:13:20,880 --> 00:13:24,000
這應該會非常快速

610
00:13:20,880 --> 00:13:24,000
 and this again should be pretty fast

611
00:13:24,000 --> 00:13:28,480
就這樣閱讀這 100 個面具

612
00:13:24,000 --> 00:13:28,480
 there you go reading these 100 masks

613
00:13:28,480 --> 00:13:30,720
隨時應該就會完成

614
00:13:28,480 --> 00:13:30,720
 and anytime it should be done

615
00:13:30,720 --> 00:13:34,240
然後我們就可以重新開始了

616
00:13:30,720 --> 00:13:34,240
 and then we are back in business

617
00:13:34,240 --> 00:13:34,720
好的

618
00:13:34,240 --> 00:13:34,720
 okay

619
00:13:34,720 --> 00:13:36,160
現在我們繼續

620
00:13:34,720 --> 00:13:36,160
 so now let's go ahead

621
00:13:36,160 --> 00:13:38,639
並且列印出我們影像遮罩的形狀

622
00:13:36,160 --> 00:13:38,639
 and print out the shape of our images masks

623
00:13:38,639 --> 00:13:38,959
和

624
00:13:38,639 --> 00:13:38,959
 and

625
00:13:38,959 --> 00:13:41,760
影像中的最大像素值是多少

626
00:13:38,959 --> 00:13:41,760
 what is the maximum pixel value in the image

627
00:13:41,760 --> 00:13:43,440
以及遮罩中的標籤

628
00:13:41,760 --> 00:13:43,440
 and also the labels in the masks

629
00:13:43,440 --> 00:13:45,519
好的，我們會看看為什麼這些很重要

630
00:13:43,440 --> 00:13:45,519
 okay we will see why these are important

631
00:13:45,519 --> 00:13:46,320
所以

632
00:13:45,519 --> 00:13:46,320
 so

633
00:13:46,320 --> 00:13:51,199
我們來打印這些，所以我們應該會有 100 張圖片，很明顯我們把數量從 1000 改為 100

634
00:13:46,320 --> 00:13:51,199
 let's print these so we should have 100 images obviously we changed from 1000 to 100

635
00:13:51,199 --> 00:13:55,519
所以這就是每張影像所代表的，每張影像是 256 乘 256 乘 1

636
00:13:51,199 --> 00:13:55,519
 so that's what that represents each image is 256 by 256 by one

637
00:13:55,519 --> 00:13:58,880
而那個 1 是因為它是灰階影像，我們

638
00:13:55,519 --> 00:13:58,880
 and that one is because it's a grayscale image and we

639
00:13:58,880 --> 00:14:01,680
對於遮罩，我們也有差不多相同的

640
00:13:58,880 --> 00:14:01,680
 also have pretty much the same for masks

641
00:14:01,680 --> 00:14:07,120
現在最大像素值為 255

642
00:14:01,680 --> 00:14:07,120
 now maximum pixel value is 255

643
00:14:07,120 --> 00:14:08,000
在我們的圖像中

644
00:14:07,120 --> 00:14:08,000
 in our images

645
00:14:08,000 --> 00:14:09,279
因為我們尚未進行正規化

646
00:14:08,000 --> 00:14:09,279
 because we haven't normalized

647
00:14:09,279 --> 00:14:09,920
或縮放

648
00:14:09,279 --> 00:14:09,920
 or scaled

649
00:14:09,920 --> 00:14:14,079
或將標籤圖像輸入到遮罩中，標籤也為 0

650
00:14:09,920 --> 00:14:14,079
 or input images the labels in the mask are also 0

651
00:14:14,079 --> 00:14:16,720
並且 255 0 對應於背景

652
00:14:14,079 --> 00:14:16,720
 and 255 0 corresponds to the background

653
00:14:16,720 --> 00:14:18,720
這是黑色背景

654
00:14:16,720 --> 00:14:18,720
 which is the black background

655
00:14:18,720 --> 00:14:21,600
和 255 對應於這些明亮的圖像，這正是

656
00:14:18,720 --> 00:14:21,600
 and 255 corresponds to these bright images that's exactly

657
00:14:21,600 --> 00:14:23,920
他們如何提供他們的數據集

658
00:14:21,600 --> 00:14:23,920
 how they provided their data set

659
00:14:23,920 --> 00:14:26,399
標籤 0 到 55 沒有問題

660
00:14:23,920 --> 00:14:26,399
 nothing wrong with label 0 to 55

661
00:14:26,399 --> 00:14:28,880
我喜歡將標籤設定為 0 1 2 3。

662
00:14:26,399 --> 00:14:28,880
 i like the labels to be 0 1 2 3.

663
00:14:28,880 --> 00:14:32,800
所以我將這個除以 255，同樣也將這個除以 255。

664
00:14:28,880 --> 00:14:32,800
 so i'm going to divide this by 255 also divide this by 255

665
00:14:32,800 --> 00:14:35,040
所以我們有了縮放。

666
00:14:32,800 --> 00:14:35,040
 so we have scaling

667
00:14:35,040 --> 00:14:37,600
您可以選擇使用最小最大標準化，而不是進行分割

668
00:14:35,040 --> 00:14:37,600
 instead of dividing you can also do min max scalar

669
00:14:37,600 --> 00:14:39,600
或規範這些東西

670
00:14:37,600 --> 00:14:39,600
 or normalize any of those things

671
00:14:39,600 --> 00:14:43,279
所以我選擇了簡單的方法，這樣就可以了

672
00:14:39,600 --> 00:14:43,279
 so but i chose the easy way this works fine

673
00:14:43,279 --> 00:14:47,920
是將我的影像數據集和匹配數據集除以 255。這樣就好了

674
00:14:43,279 --> 00:14:47,920
 is divide my image data set and match dataset by 255. there you go

675
00:14:47,920 --> 00:14:50,399
現在我們的值將會是 0

676
00:14:47,920 --> 00:14:50,399
 and now our values will be just 0

677
00:14:50,399 --> 00:14:52,720
或者 1 來對應我的遮罩

678
00:14:50,399 --> 00:14:52,720
 or 1 for my mask

679
00:14:52,720 --> 00:14:55,440
和 0 到 1

680
00:14:52,720 --> 00:14:55,440
 and 0 to 1

681
00:14:55,440 --> 00:14:56,480
用於我的圖像

682
00:14:55,440 --> 00:14:56,480
 for my images

683
00:14:56,480 --> 00:15:01,519
到目前為止，一切順利，我們還沒做太多事情，我們只是

684
00:14:56,480 --> 00:15:01,519
 so far so good again we haven't done much of anything we just

685
00:15:01,519 --> 00:15:02,880
整理了我們的圖像

686
00:15:01,519 --> 00:15:02,880
 sorted our images

687
00:15:02,880 --> 00:15:08,000
並以排序後的順序載入了前 100 張圖像

688
00:15:02,880 --> 00:15:08,000
 and loaded the first 100 images in in that sorted order

689
00:15:08,000 --> 00:15:09,760
和我們的面具一樣

690
00:15:08,000 --> 00:15:09,760
 and same with our masks

691
00:15:09,760 --> 00:15:11,760
然後我們意識到我們的圖像

692
00:15:09,760 --> 00:15:11,760
 and then we realized our images

693
00:15:11,760 --> 00:15:13,600
和面具需要調整大小

694
00:15:11,760 --> 00:15:13,600
 and masks need to be scaled

695
00:15:13,600 --> 00:15:17,279
然後我們把它們除以 255 學校來縮放，僅此而已

696
00:15:13,600 --> 00:15:17,279
 and then we just divided them by 255 school to scale them that's it

697
00:15:17,279 --> 00:15:19,120
現在我正在劃分我的圖像

698
00:15:17,279 --> 00:15:19,120
 now i'm dividing my images

699
00:15:19,120 --> 00:15:23,440
和掩碼成 80 用於訓練，20 用於測試

700
00:15:19,120 --> 00:15:23,440
 and masks into 80 for training 20 for testing

701
00:15:23,440 --> 00:15:23,920
好的

702
00:15:23,440 --> 00:15:23,920
 okay

703
00:15:23,920 --> 00:15:26,720
那麼我們就去做這個，即使我們不打算進行訓練

704
00:15:23,920 --> 00:15:26,720
 so let's go ahead and do that even though we're not gonna train

705
00:15:26,720 --> 00:15:32,880
我這麼做的原因是進行一次基本檢查總是個好主意，這意味著

706
00:15:26,720 --> 00:15:32,880
 the reason i'm doing that is it's always good idea to perform a sanity check meaning

707
00:15:32,880 --> 00:15:37,279
嘿，生成一個介於 0 到 100 之間的隨機數字，在這個情況下

708
00:15:32,880 --> 00:15:37,279
 hey generate a random number between 0 to 100 in this case

709
00:15:37,279 --> 00:15:38,839
或 99

710
00:15:37,279 --> 00:15:38,839
 or 99

711
00:15:38,839 --> 00:15:42,560
並繪製或標記你的圖像

712
00:15:38,839 --> 00:15:42,560
 and map out or plot your images

713
00:15:42,560 --> 00:15:44,560
和面具

714
00:15:42,560 --> 00:15:44,560
 and masks

715
00:15:44,560 --> 00:15:46,160
查看它們是否對齊，這正是

716
00:15:44,560 --> 00:15:46,160
 see if they're lining up that's exactly

717
00:15:46,160 --> 00:15:47,360
我在這裡嘗試做的

718
00:15:46,160 --> 00:15:47,360
 what i'm trying to do here

719
00:15:47,360 --> 00:15:50,720
如果它們對齊，那我就可以開始了，所以這看起來非常好

720
00:15:47,360 --> 00:15:50,720
 if they line up i'm good to go right so that looks very good

721
00:15:50,720 --> 00:15:52,560
這看起來像那些圖片

722
00:15:50,720 --> 00:15:52,560
 that looks like the images

723
00:15:52,560 --> 00:15:57,519
以及面具，讓我們載入另一張隨機圖片，沒有問題，太好了

724
00:15:52,560 --> 00:15:57,519
 and masks let's load another random image nothing there great

725
00:15:57,519 --> 00:15:57,920
好的

726
00:15:57,519 --> 00:15:57,920
 okay

727
00:15:57,920 --> 00:16:01,519
所以一切都對應上了，這點非常重要，因為

728
00:15:57,920 --> 00:16:01,519
 so everything is matching up this is this is very important to do because

729
00:16:01,519 --> 00:16:03,440
你正在從磁碟載入資料對吧

730
00:16:01,519 --> 00:16:03,440
 you're loading data from the disk right

731
00:16:03,440 --> 00:16:04,560
然後繼續進行

732
00:16:03,440 --> 00:16:04,560
 so and then go ahead

733
00:16:04,560 --> 00:16:08,399
並定義你的模型，我們在上一個影片中已經講解過這一點

734
00:16:04,560 --> 00:16:08,399
 and define your model we covered this in the last video

735
00:16:08,399 --> 00:16:12,720
正確定義卷積區塊，定義編碼器區塊

736
00:16:08,399 --> 00:16:12,720
 right defining the convolution block defining the encoder block

737
00:16:12,720 --> 00:16:14,079
這兩個

738
00:16:12,720 --> 00:16:14,079
 which gives you these two

739
00:16:14,079 --> 00:16:15,440
和解碼器

740
00:16:14,079 --> 00:16:15,440
 and a decoder

741
00:16:15,440 --> 00:16:16,480
塊，這是我們的模型

742
00:16:15,440 --> 00:16:16,480
 block and this is our model

743
00:16:16,480 --> 00:16:19,440
我不想浪費你的時間來講這些

744
00:16:16,480 --> 00:16:19,440
 again i don't want to waste your time by going through this

745
00:16:19,440 --> 00:16:22,320
因為我們在上一個影片中花了半小時談論這個

746
00:16:19,440 --> 00:16:22,320
 because we spent half an hour talking about this in the last video

747
00:16:22,320 --> 00:16:22,959
好的

748
00:16:22,320 --> 00:16:22,959
 okay

749
00:16:22,959 --> 00:16:25,040
我們定義了這個模型

750
00:16:22,959 --> 00:16:25,040
 so we defined this model

751
00:16:25,040 --> 00:16:28,240
當我調用它時，它會返回這個模型

752
00:16:25,040 --> 00:16:28,240
 and when i call it it's going to return this model

753
00:16:28,240 --> 00:16:30,399
那麼我該如何調用它呢

754
00:16:28,240 --> 00:16:30,399
 so how do i call it well

755
00:16:30,399 --> 00:16:32,560
在哪裡給它輸入形狀

756
00:16:30,399 --> 00:16:32,560
 where is it give it input shape

757
00:16:32,560 --> 00:16:34,880
和類別數量正確

758
00:16:32,560 --> 00:16:34,880
 and number of classes right

759
00:16:34,880 --> 00:16:36,880
我們還添加了這些行

760
00:16:34,880 --> 00:16:36,880
 and we also added these lines

761
00:16:36,880 --> 00:16:39,040
如果我的類別數量不是二元的

762
00:16:36,880 --> 00:16:39,040
 so if my number of classes are not binary

763
00:16:39,040 --> 00:16:40,800
那麼它將使用 softmax

764
00:16:39,040 --> 00:16:40,800
 then it's going to use softmax

765
00:16:40,800 --> 00:16:41,680
如果是二元的

766
00:16:40,800 --> 00:16:41,680
 if it is binary

767
00:16:41,680 --> 00:16:44,480
意味著類別數量等於一，記住二進位

768
00:16:41,680 --> 00:16:44,480
 meaning number of classes equals to one remember binary

769
00:16:44,480 --> 00:16:47,120
這並不意味著兩個二進位代表一個輸出

770
00:16:44,480 --> 00:16:47,120
 doesn't mean two binary means one output

771
00:16:47,120 --> 00:16:49,120
是的，那麼它將使用 sigmoid

772
00:16:47,120 --> 00:16:49,120
 yeah then it's going to use sigmoid

773
00:16:49,120 --> 00:16:50,800
所以我的輸入維度

774
00:16:49,120 --> 00:16:50,800
 so my input dimensions

775
00:16:50,800 --> 00:16:53,360
或者輸入形狀是我的圖像高度寬度

776
00:16:50,800 --> 00:16:53,360
 or input shape is my image height width

777
00:16:53,360 --> 00:16:54,560
以及通道數量

778
00:16:53,360 --> 00:16:54,560
 and number of channels

779
00:16:54,560 --> 00:16:56,480
即 256 到 56 1.

780
00:16:54,560 --> 00:16:56,480
 which is 256 to 56 1.

781
00:16:56,480 --> 00:16:58,000
所以讓我們繼續定義這個

782
00:16:56,480 --> 00:16:58,000
 so let's go ahead and define that

783
00:16:58,000 --> 00:17:01,360
然後建立模型

784
00:16:58,000 --> 00:17:01,360
 and then build the model

785
00:17:01,360 --> 00:17:02,959
非常簡單，你提供這個

786
00:17:01,360 --> 00:17:02,959
 very simple you provide this

787
00:17:02,959 --> 00:17:08,079
然後我們將使用 Adam 作為優化器來編譯模型

788
00:17:02,959 --> 00:17:08,079
 and then we are going to compile the model by using adam as our optimizer

789
00:17:08,079 --> 00:17:11,839
二元交叉熵 這是一個二元語義分割

790
00:17:08,079 --> 00:17:11,839
 binary cross entropy this is a binary semantic segmentation

791
00:17:11,839 --> 00:17:16,400
和指標 我們將使用準確度來訓練指標 就像我說的 交集

792
00:17:11,839 --> 00:17:16,400
 and metrics we are going to use accuracy to train the metrics again like i said intersection

793
00:17:16,400 --> 00:17:19,599
聯合度是一個更好的指標來追蹤

794
00:17:16,400 --> 00:17:19,599
 over union is a better metric to track

795
00:17:19,599 --> 00:17:22,079
對於語義分割，我們會在未來涵蓋這個主題

796
00:17:19,599 --> 00:17:22,079
 for semantic segmentation we'll cover that in future

797
00:17:22,079 --> 00:17:24,480
但準確度有效，並不是那樣的

798
00:17:22,079 --> 00:17:24,480
 but accuracy works it's not like it

799
00:17:24,480 --> 00:17:26,720
但它只是不告訴你有多好

800
00:17:24,480 --> 00:17:26,720
 but it just doesn't tell you how good the

801
00:17:26,720 --> 00:17:32,000
這裡在我的時期中，1 項中的 25 項，真是太好了

802
00:17:26,720 --> 00:17:32,000
 how good it is because here in my epoch 1 out of 25

803
00:17:32,000 --> 00:17:34,000
或

804
00:17:32,000 --> 00:17:34,000
 or

805
00:17:34,000 --> 00:17:39,360
時期一，是的，這是我的時期一中的 50 項中的一項，我應該這麼說

806
00:17:34,000 --> 00:17:39,360
 epoch one yeah this is my epoch one out of 50. i should say

807
00:17:39,360 --> 00:17:42,799
我做了多少個時期，抱歉，我做了 25 個時期

808
00:17:39,360 --> 00:17:42,799
 how many epochs did i do sorry i did 25 epochs

809
00:17:42,799 --> 00:17:44,720
這 50 個是 50 次迭代

810
00:17:42,799 --> 00:17:44,720
 and these 50 are 50 iterations

811
00:17:44,720 --> 00:17:46,400
所以 1/25

812
00:17:44,720 --> 00:17:46,400
 so 1 out of 25

813
00:17:46,400 --> 00:17:51,440
在第一個時期準確度對驗證來說很差，而在第二個時期為 92

814
00:17:46,400 --> 00:17:51,440
 in the first epoch the accuracy was bad for validation in the second epoch it's 92

815
00:17:51,440 --> 00:17:54,000
突然之間

816
00:17:51,440 --> 00:17:54,000
 all of a sudden

817
00:17:54,000 --> 00:17:55,520
那這是好還是壞呢？

818
00:17:54,000 --> 00:17:55,520
 but is that good or bad

819
00:17:55,520 --> 00:17:58,320
我們不知道，對吧？我的意思是，這就是精確度的問題所在

820
00:17:55,520 --> 00:17:58,320
 we don't know right i mean this is what the problem is with accuracy

821
00:17:58,320 --> 00:18:01,440
所以當我往下走時，我的準確率是 99%

822
00:17:58,320 --> 00:18:01,440
 so as i go down i got 99 accuracy

823
00:18:01,440 --> 00:18:02,240
但交集

824
00:18:01,440 --> 00:18:02,240
 but intersection

825
00:18:02,240 --> 00:18:03,360
與聯集將會找到

826
00:18:02,240 --> 00:18:03,360
 over union will find

827
00:18:03,360 --> 00:18:06,559
判斷它是好還是壞，然後我保存了我的模型

828
00:18:03,360 --> 00:18:06,559
 out if it is good or bad and then i saved my model

829
00:18:06,559 --> 00:18:06,880
好的

830
00:18:06,559 --> 00:18:06,880
 okay

831
00:18:06,880 --> 00:18:08,000
現在我們下去吧

832
00:18:06,880 --> 00:18:08,000
 now let's go down

833
00:18:08,000 --> 00:18:09,919
這就是圖表的樣子

834
00:18:08,000 --> 00:18:09,919
 and this is how the plots look like

835
00:18:09,919 --> 00:18:11,280
那麼我們繼續前進

836
00:18:09,919 --> 00:18:11,280
 and let's go ahead

837
00:18:11,280 --> 00:18:13,760
並載入模型

838
00:18:11,280 --> 00:18:13,760
 and load the model

839
00:18:13,760 --> 00:18:17,440
我們將其儲存為這個名稱，所以我們繼續

840
00:18:13,760 --> 00:18:17,440
 so we saved this under this name so let's go ahead

841
00:18:17,440 --> 00:18:20,320
並載入模型，我將設置 compile 為 false

842
00:18:17,440 --> 00:18:20,320
 and load the model i'm going to put compile equals to false

843
00:18:20,320 --> 00:18:25,360
因為我不再進行進一步的訓練，我只是用這個模型來進行推斷，就這樣

844
00:18:20,320 --> 00:18:25,360
 because i'm not further training using this i'm just using the model for inference that's it

845
00:18:25,360 --> 00:18:26,400
好的

846
00:18:25,360 --> 00:18:26,400
 okay

847
00:18:26,400 --> 00:18:30,160
以及交集比率（Intersection over Union，IoU）計算

848
00:18:26,400 --> 00:18:30,160
 and for intersection over union calculation

849
00:18:30,160 --> 00:18:32,240
我的意思是你可以追蹤交集佔並集比例

850
00:18:30,160 --> 00:18:32,240
 i mean you can track intersection over union

851
00:18:32,240 --> 00:18:35,200
這是你應該在每個時代（epoch）進行的操作

852
00:18:32,240 --> 00:18:35,200
 which is what you should do for every epoch

853
00:18:35,200 --> 00:18:36,480
而這僅在

854
00:18:35,200 --> 00:18:36,480
 and that only happens

855
00:18:36,480 --> 00:18:40,640
如果你把交集與聯合比作為你在這裡追蹤的指標之一

856
00:18:36,480 --> 00:18:40,640
 if you put that intersection over union as part of your metrics that you're tracking here

857
00:18:40,640 --> 00:18:45,520
但完成後，你可以計算整個數據集的交集與聯合比

858
00:18:40,640 --> 00:18:45,520
 but once it's done you can calculate intersection over union over your entire data

859
00:18:45,520 --> 00:18:49,600
這就是我們在這裡嘗試做的

860
00:18:45,520 --> 00:18:49,600
 that's what we are trying to do down here

861
00:18:49,600 --> 00:18:52,400
首先，我們需要進行預測

862
00:18:49,600 --> 00:18:52,400
 first of all we need to predict

863
00:18:52,400 --> 00:18:55,919
在我們的測試數據集上

864
00:18:52,400 --> 00:18:55,919
 on our test data set

865
00:18:55,919 --> 00:18:56,400
好的

866
00:18:55,919 --> 00:18:56,400
 yeah

867
00:18:56,400 --> 00:19:00,000
所以我們來進行預測，在我們的情況下，測試數據集只有 20 張圖片

868
00:18:56,400 --> 00:19:00,000
 so let's go ahead and predict in our case our test data set is only 20 images

869
00:19:00,000 --> 00:19:06,559
因為我們只讀取了幾百個，我應該更改過來，但讓我們檢查一下我們的 model.predict

870
00:19:00,000 --> 00:19:06,559
 because we only are reading hundred i should have changed that but let's check our model.predict

871
00:19:06,559 --> 00:19:07,919
你怎麼預測

872
00:19:06,559 --> 00:19:07,919
 how do you predict

873
00:19:07,919 --> 00:19:14,400
model.predict，再次說明這與分類相同，沒關係，始終是 model.predict

874
00:19:07,919 --> 00:19:14,400
 model.predict again this is same as in classification it doesn't matter it's always model.predict

875
00:19:14,400 --> 00:19:19,280
我在我的 x 測試數據集中進行預測，那是 20 張圖像

876
00:19:14,400 --> 00:19:19,280
 and i'm predicting on my x test data set that's 20 images

877
00:19:19,280 --> 00:19:24,080
然後我將應用 0.5 的閾值

878
00:19:19,280 --> 00:19:24,080
 and then i'm going to apply a threshold of 0.5

879
00:19:24,080 --> 00:19:26,000
這意味著它會轉換

880
00:19:24,080 --> 00:19:26,000
 which means it converts

881
00:19:26,000 --> 00:19:28,240
每個值的機率

882
00:19:26,000 --> 00:19:28,240
 every value probability

883
00:19:28,240 --> 00:19:32,080
因為當你執行 model.predict 時，它會給你 sigmoid

884
00:19:28,240 --> 00:19:32,080
 because when you do model.predict it's going to give you sigmoid

885
00:19:32,080 --> 00:19:35,760
我一直回到基本概念，但這些非常重要

886
00:19:32,080 --> 00:19:35,760
 i keep going back to the basics here but again these are very important

887
00:19:35,760 --> 00:19:38,240
我們正在使用 你正在使用

888
00:19:35,760 --> 00:19:38,240
 we are using you're using

889
00:19:38,240 --> 00:19:42,320
激活函數為 sigmoid

890
00:19:38,240 --> 00:19:42,320
 activation function as sigmoid

891
00:19:42,320 --> 00:19:45,600
在這裡，sigmoid 函數會給出介於 0

892
00:19:42,320 --> 00:19:45,600
 right here a sigmoid gives you probability between 0

893
00:19:45,600 --> 00:19:46,400
和 1

894
00:19:45,600 --> 00:19:46,400
 and 1

895
00:19:46,400 --> 00:19:50,000
這意味著我們需要將那個概率轉換成類別

896
00:19:46,400 --> 00:19:50,000
 which means we have to convert that probability into class

897
00:19:50,000 --> 00:19:51,039
而那就是

898
00:19:50,000 --> 00:19:51,039
 and that's

899
00:19:51,039 --> 00:19:54,320
我們就用我們的閾值來做這件事

900
00:19:51,039 --> 00:19:54,320
 what we do with our threshold right there

901
00:19:54,320 --> 00:19:54,880
好的

902
00:19:54,320 --> 00:19:54,880
 okay

903
00:19:54,880 --> 00:19:59,520
我們將放入每個值

904
00:19:54,880 --> 00:19:59,520
 so we are going to put every value

905
00:19:59,520 --> 00:20:01,840
預測值超過 0.5

906
00:19:59,520 --> 00:20:01,840
 predicted value above 0.5

907
00:20:01,840 --> 00:20:03,760
我會稱它為線粒體

908
00:20:01,840 --> 00:20:03,760
 i'm going to call it mitochondria

909
00:20:03,760 --> 00:20:04,880
那就是這樣

910
00:20:03,760 --> 00:20:04,880
 that's what that is

911
00:20:04,880 --> 00:20:09,679
所以我們來計算交集與聯合比率，你可以進行導入

912
00:20:04,880 --> 00:20:09,679
 so let's calculate intersection over union the way you do that is go ahead and import

913
00:20:09,679 --> 00:20:12,000
從 keras.metrics 導入 iou

914
00:20:09,679 --> 00:20:12,000
 mean iou from keras.metrics

915
00:20:12,000 --> 00:20:14,400
並應用這個，這僅適用於 TensorFlow

916
00:20:12,000 --> 00:20:14,400
 and apply that and this only works on tensorflow

917
00:20:14,400 --> 00:20:17,200
2 及之後，之前你沒有那個意思的 IOU

918
00:20:14,400 --> 00:20:17,200
 2 and later before that you don't have that mean iou

919
00:20:17,200 --> 00:20:18,880
所以可能會引發一些錯誤

920
00:20:17,200 --> 00:20:18,880
 so it may throw some error

921
00:20:18,880 --> 00:20:21,840
希望你們都在使用 TensorFlow 2 或更高版本

922
00:20:18,880 --> 00:20:21,840
 okay hopefully you're all working on tensorflow 2 or later

923
00:20:21,840 --> 00:20:26,720
因此，對於 IoU 計算，我會說我的類別數量等於 2

924
00:20:21,840 --> 00:20:26,720
 so and for iou calculations i'm going to say my number of classes equals to 2

925
00:20:26,720 --> 00:20:27,679
因為我有 0

926
00:20:26,720 --> 00:20:27,679
 because i have 0

927
00:20:27,679 --> 00:20:30,000
和 1. 這可能會令人困惑

928
00:20:27,679 --> 00:20:30,000
 and 1. this may be confusing

929
00:20:30,000 --> 00:20:33,200
但對於 Keras 的 IOU，你有 2 0

930
00:20:30,000 --> 00:20:33,200
 but for keras iou you have 2 0

931
00:20:33,200 --> 00:20:33,840
和一個

932
00:20:33,200 --> 00:20:33,840
 and one

933
00:20:33,840 --> 00:20:35,760
所以它會看起來好，你有零

934
00:20:33,840 --> 00:20:35,760
 so it's going to look at okay you have zero

935
00:20:35,760 --> 00:20:36,320
和一個

936
00:20:35,760 --> 00:20:36,320
 and one

937
00:20:36,320 --> 00:20:39,520
那麼讓我計算 IOU，這就是它在做的事

938
00:20:36,320 --> 00:20:39,520
 so let me calculate iou that's what this is doing

939
00:20:39,520 --> 00:20:43,760
所以你在這裡用類別數來實例化平均 IOU

940
00:20:39,520 --> 00:20:43,760
 so you instantiate mean iou right there with number of classes

941
00:20:43,760 --> 00:20:49,440
然後你使用從這裡得到的預測值來更新其狀態

942
00:20:43,760 --> 00:20:49,440
 and then you update the status of that using your predicted values from here

943
00:20:49,440 --> 00:20:51,039
我將使用閾值

944
00:20:49,440 --> 00:20:51,039
 i'm going to use the thresholded

945
00:20:51,039 --> 00:20:53,440
然後是測試值對吧

946
00:20:51,039 --> 00:20:53,440
 and then the test values right

947
00:20:53,440 --> 00:20:53,760
所以

948
00:20:53,440 --> 00:20:53,760
 so

949
00:20:53,760 --> 00:20:56,480
然後繼續打印結果

950
00:20:53,760 --> 00:20:56,480
 and then go ahead and print the result

951
00:20:56,480 --> 00:21:01,200
所以之前用我不確定的 200 張圖片，我得到 91 的 IoU

952
00:20:56,480 --> 00:21:01,200
 so previously with my i don't know 200 images i got 91 iou

953
00:21:01,200 --> 00:21:06,400
這非常棒，我應該說平均 IoU 是 92，這很棒，意味著

954
00:21:01,200 --> 00:21:06,400
 which is excellent by the way i should say mean iou 92 great that means

955
00:21:06,400 --> 00:21:10,240
這個線粒體的交並比

956
00:21:06,400 --> 00:21:10,240
 the the intersection over union for this mitochondria

957
00:21:10,240 --> 00:21:14,799
背景的交並比達到 92％

958
00:21:10,240 --> 00:21:14,799
 and the background we have 92 percent you know for that

959
00:21:14,799 --> 00:21:19,360
對於語義分割，任何超過 90 的交並比都是優秀的

960
00:21:14,799 --> 00:21:19,360
 and anything above 90 for semantic segmentation iou is excellent

961
00:21:19,360 --> 00:21:22,320
那麼我們設定 0.5 作為閾值

962
00:21:19,360 --> 00:21:22,320
 so let us set a threshold of 0.5

963
00:21:22,320 --> 00:21:29,120
而這部分的代碼基本上是載入圖像

964
00:21:22,320 --> 00:21:29,120
 and do exactly this part of the code is basically loading an image

965
00:21:29,120 --> 00:21:31,120
希望是一張隨機圖像，就在那裡

966
00:21:29,120 --> 00:21:31,120
 hopefully a random image yeah right there

967
00:21:31,120 --> 00:21:33,919
從我們的測試數據集中加載一個隨機圖像

968
00:21:31,120 --> 00:21:33,919
 so loading a random image from our test data set

969
00:21:33,919 --> 00:21:34,799
然後預測

970
00:21:33,919 --> 00:21:34,799
 and then predicting

971
00:21:34,799 --> 00:21:37,600
和列印，就是這樣繪圖

972
00:21:34,799 --> 00:21:37,600
 and printing that's it plotting

973
00:21:37,600 --> 00:21:40,000
那我們來做吧

974
00:21:37,600 --> 00:21:40,000
 so let's do that

975
00:21:40,000 --> 00:21:41,120
這裡沒什麼好看的

976
00:21:40,000 --> 00:21:41,120
 not much to see here

977
00:21:41,120 --> 00:21:42,640
我們再試一次，希望能成功

978
00:21:41,120 --> 00:21:42,640
 let's run it one more time hopefully

979
00:21:42,640 --> 00:21:44,159
我們會得到更好的影像

980
00:21:42,640 --> 00:21:44,159
 we'll get a better image

981
00:21:44,159 --> 00:21:48,240
天啊，我們有所有空白的圖片，這是你的測試標籤

982
00:21:44,159 --> 00:21:48,240
 god we have all empty images there you go this is your testing label

983
00:21:48,240 --> 00:21:50,159
這是我們得到的結果

984
00:21:48,240 --> 00:21:50,159
 this is what we got

985
00:21:50,159 --> 00:21:53,760
預測結果並不那麼驚人

986
00:21:50,159 --> 00:21:53,760
 the prediction isn't that amazing

987
00:21:53,760 --> 00:21:56,880
非常好的分段

988
00:21:53,760 --> 00:21:56,880
 very good segmentation

989
00:21:57,120 --> 00:21:59,840
沒有任何內容

990
00:21:57,120 --> 00:21:59,840
 nothing there

991
00:21:59,840 --> 00:22:04,640
我們有許多空的數據集，這也不算壞

992
00:21:59,840 --> 00:22:04,640
 we have many many empty data sets that is also not bad

993
00:22:04,640 --> 00:22:06,640
讓我們把這個改為 x train

994
00:22:04,640 --> 00:22:06,640
 let's change this to x train

995
00:22:06,640 --> 00:22:10,720
因為我們在訓練中有更多的數據

996
00:22:06,640 --> 00:22:10,720
 because we have more data in the train

997
00:22:10,720 --> 00:22:13,520
我們繼續檢查一下，你也可以載入外部

998
00:22:10,720 --> 00:22:13,520
 and let's go ahead and check it you can also load external

999
00:22:13,520 --> 00:22:14,880
圖像來檢查情況

1000
00:22:13,520 --> 00:22:14,880
 image to check things out

1001
00:22:14,880 --> 00:22:15,280
好的

1002
00:22:14,880 --> 00:22:15,280
 yeah

1003
00:22:15,280 --> 00:22:16,640
所以那就是

1004
00:22:15,280 --> 00:22:16,640
 so there you go that's

1005
00:22:16,640 --> 00:22:17,840
我的意思是，這並不完美

1006
00:22:16,640 --> 00:22:17,840
 i mean it's not perfect

1007
00:22:17,840 --> 00:22:23,200
但這不是壞的分段，它正在檢測

1008
00:22:17,840 --> 00:22:23,200
 but that's not bad segmentation it is detecting

1009
00:22:24,840 --> 00:22:26,159
粒線體

1010
00:22:24,840 --> 00:22:26,159
 mitochondria

1011
00:22:26,159 --> 00:22:28,799
啊，我覺得

1012
00:22:26,159 --> 00:22:28,799
 ah i think

1013
00:22:28,799 --> 00:22:34,000
哦，我應該說 x 列減一，抱歉

1014
00:22:28,799 --> 00:22:34,000
 oh i should have said x train minus one sorry

1015
00:22:34,640 --> 00:22:37,600
好了，就這樣

1016
00:22:34,640 --> 00:22:37,600
 okay there you go

1017
00:22:37,600 --> 00:22:40,159
稍微好一些會更好

1018
00:22:37,600 --> 00:22:40,159
 a little bit it can be better

1019
00:22:40,159 --> 00:22:41,440
再來一次

1020
00:22:40,159 --> 00:22:41,440
 and one final time

1021
00:22:41,440 --> 00:22:43,440
是的，我們已經看過這個了

1022
00:22:41,440 --> 00:22:43,440
 yeah we already saw this

1023
00:22:43,440 --> 00:22:45,360
所以我不確定

1024
00:22:43,440 --> 00:22:45,360
 so i'm not sure

1025
00:22:45,360 --> 00:22:48,799
為什麼它沒有查看測試編號

1026
00:22:45,360 --> 00:22:48,799
 why it's not looking at test number

1027
00:22:48,799 --> 00:22:50,240
但這沒問題

1028
00:22:48,799 --> 00:22:50,240
 but this is fine

1029
00:22:50,240 --> 00:22:53,360
x 測試，讓我們在之前改為測試

1030
00:22:50,240 --> 00:22:53,360
 x test let's change this to test before

1031
00:22:53,360 --> 00:22:57,520
我會與你分享代碼，不然你會想知道為什麼我在使用 train

1032
00:22:53,360 --> 00:22:57,520
 i share the code with you otherwise you'll be wondering why i'm using train

1033
00:22:57,520 --> 00:23:00,640
好的，我保證不再多說

1034
00:22:57,520 --> 00:23:00,640
 okay i promise no more more

1035
00:23:00,640 --> 00:23:02,640
好，讓我們以這個結尾吧

1036
00:23:00,640 --> 00:23:02,640
 yeah let's let's end on this note

1037
00:23:02,640 --> 00:23:04,720
那我們學到了什麼

1038
00:23:02,640 --> 00:23:04,720
 so what did we learn

1039
00:23:04,720 --> 00:23:08,320
一旦你定義了你的單位

1040
00:23:04,720 --> 00:23:08,320
 once you define your unit

1041
00:23:08,320 --> 00:23:12,080
這非常簡單，其餘的都是數據處理

1042
00:23:08,320 --> 00:23:12,080
 it's very easy everything else is data handling

1043
00:23:12,080 --> 00:23:14,320
你只需將數據劃分為額外的索引測試

1044
00:23:12,080 --> 00:23:14,320
 you just divide your data into extra index test

1045
00:23:14,320 --> 00:23:15,440
傳遞給你的單元

1046
00:23:14,320 --> 00:23:15,440
 pass it to your unit

1047
00:23:15,440 --> 00:23:16,960
讓單位發揮其魔力

1048
00:23:15,440 --> 00:23:16,960
 let unit do its magic

1049
00:23:16,960 --> 00:23:20,720
然後通常它在下一個視頻中表現出色，讓我們看看多類別

1050
00:23:16,960 --> 00:23:20,720
 and then usually it works great in the next video let's look at multi-class

1051
00:23:20,720 --> 00:23:23,200
這與二分類略有不同

1052
00:23:20,720 --> 00:23:23,200
 which is slightly different from binary

1053
00:23:23,200 --> 00:23:25,600
因為你必須將圖像轉換為類別

1054
00:23:23,200 --> 00:23:25,600
 because you have to convert your images to categorical

1055
00:23:25,600 --> 00:23:30,320
除此之外，其他一切都相同，我們將使用完全相同的

1056
00:23:25,600 --> 00:23:30,320
 other than that everything else is the same we are going to use exactly the same

1057
00:23:30,320 --> 00:23:32,240
模型

1058
00:23:30,320 --> 00:23:32,240
 model

1059
00:23:32,240 --> 00:23:36,400
所以無論你在使用什麼，你都有一個通用模型

1060
00:23:32,240 --> 00:23:36,400
 so you have one universal model no matter what you're working with

1061
00:23:36,400 --> 00:23:37,039
好的

1062
00:23:36,400 --> 00:23:37,039
 okay

1063
00:23:37,039 --> 00:23:37,440
所以

1064
00:23:37,039 --> 00:23:37,440
 so

1065
00:23:37,440 --> 00:23:39,120
再次在下個影片中見面

1066
00:23:37,440 --> 00:23:39,120
 again let's meet again in the next

1067
00:23:39,120 --> 00:23:42,159
影片，直到那時不要忘記訂閱這個頻道，謝謝大家

1068
00:23:39,120 --> 00:23:42,159
 video until then do not forget to subscribe to this channel thank you guys

