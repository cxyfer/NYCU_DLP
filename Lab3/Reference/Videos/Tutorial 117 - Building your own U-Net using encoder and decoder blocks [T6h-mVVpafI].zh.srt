1
00:00:00,799 --> 00:00:06,720
嗨大家，歡迎來到介紹性 Python 教學，特別關注於影像處理

2
00:00:06,720 --> 00:00:12,240
在這段影片中，我們來看看如何使用編碼器建構單位

3
00:00:12,240 --> 00:00:13,360
和解碼塊

4
00:00:13,360 --> 00:00:17,279
那意味著什麼？在教程 115 中，那個

5
00:00:17,279 --> 00:00:21,920
在這之前，不是這個之前的那個，而是再之前的那個，上一個

6
00:00:21,920 --> 00:00:23,359
我們查看了單位

7
00:00:23,359 --> 00:00:30,080
然後我們實際上通過定義每一層來建立單位，就像我們定義了兩個卷積層一樣

8
00:00:30,080 --> 00:00:31,760
然後是激活層對吧

9
00:00:31,760 --> 00:00:37,200
然後我們定義了卷積層，抱歉，還有最大池化，兩個卷積層和最大池化

10
00:00:37,200 --> 00:00:38,320
以此類推

11
00:00:38,320 --> 00:00:42,640
我們意識到有一些模式這些區塊在重複

12
00:00:42,640 --> 00:00:45,920
那麼如何將這些定義為單獨的函數呢

13
00:00:45,920 --> 00:00:46,719
編碼器

14
00:00:46,719 --> 00:00:47,440
和解碼器

15
00:00:47,440 --> 00:00:50,000
然後實際上用幾行代碼構建一個單元

16
00:00:50,000 --> 00:00:51,360
這樣做可能非常有用

17
00:00:51,360 --> 00:00:57,280
如果你真的希望定義一個幾乎像是通用的單位

18
00:00:57,280 --> 00:00:59,760
只需更改幾個參數

19
00:00:59,760 --> 00:01:03,520
然後您可以將此功能自訂為二元分割

20
00:01:03,520 --> 00:01:05,840
您可以將此功能自訂為多類別分割

21
00:01:05,840 --> 00:01:08,720
那麼擴展到 3D 主題怎麼樣

22
00:01:08,720 --> 00:01:09,760
對，所以你可以，你可以

23
00:01:09,760 --> 00:01:11,040
你可以自己建造單位

24
00:01:11,040 --> 00:01:12,880
這不是非常困難

25
00:01:12,880 --> 00:01:15,920
那我們就來看看怎麼做到這點

26
00:01:15,920 --> 00:01:22,799
再次快速回顧這個單元，這是原始文獻中的單元

27
00:01:22,799 --> 00:01:24,320
和

28
00:01:24,320 --> 00:01:26,080
如您所見，我們正在往下進行

29
00:01:26,080 --> 00:01:29,680
隨著我們往下進行，會有一些特定的操作

30
00:01:29,680 --> 00:01:34,000
以及在視頻 115 教學 115 中

31
00:01:34,000 --> 00:01:37,920
我們檢視了使用 256 x 256 來實現這個單元

32
00:01:37,920 --> 00:01:40,880
1 圖像，這裡是我們檢視的結構

33
00:01:40,880 --> 00:01:44,320
我們說好，從 256 減少到 128

34
00:01:44,320 --> 00:01:51,360
減少到 64，然後到 32，再到 16。再次觀看最後的影片以了解這個解碼器部分

35
00:01:51,360 --> 00:01:53,040
我們討論了上採樣

36
00:01:53,040 --> 00:01:56,079
我們也談到了 2D 轉置

37
00:01:56,079 --> 00:02:00,240
從 16 x 16 到 32，再到 64，再到 128

38
00:02:00,240 --> 00:02:01,680
最終到 256

39
00:02:01,680 --> 00:02:04,079
這恰好是我們圖像的原始大小

40
00:02:04,079 --> 00:02:08,160
因為您希望分割後的圖像與原始圖像大小相同

41
00:02:08,160 --> 00:02:09,119
好的

42
00:02:09,119 --> 00:02:10,160
所以

43
00:02:10,160 --> 00:02:13,680
我們是通過在這裡編寫每一行來構建這個的

44
00:02:13,680 --> 00:02:15,120
所以這是我的輸入

45
00:02:15,120 --> 00:02:16,879
然後接著是兩個卷積層

46
00:02:16,879 --> 00:02:20,720
以及最大池化，兩個卷積，最大池化，右側，這正是

47
00:02:20,720 --> 00:02:22,319
我們有兩個卷積

48
00:02:22,319 --> 00:02:26,640
藍色箭頭最大池化，紅色箭頭兩個卷積，藍色箭頭，紅色箭頭

49
00:02:26,640 --> 00:02:30,319
然後我們意識到有一堆這些內容在重複

50
00:02:30,319 --> 00:02:32,879
那為什麼不直接分配區塊呢

51
00:02:32,879 --> 00:02:33,280
所以

52
00:02:33,280 --> 00:02:36,080
那我們這麼說的意思是什麼，例如

53
00:02:36,080 --> 00:02:39,280
讓我們來看看這兩個操作

54
00:02:39,280 --> 00:02:44,160
所以我們正在進行卷積，我們正在進行卷積

55
00:02:44,160 --> 00:02:46,400
和最大池化

56
00:02:46,400 --> 00:02:47,760
輸出是什麼

57
00:02:47,760 --> 00:02:49,200
在每個這些之後

58
00:02:49,200 --> 00:02:51,280
所以我正在分配某些

59
00:02:51,280 --> 00:02:56,879
我說，卷積層的輸出是 s1

60
00:02:56,879 --> 00:03:00,800
在這一點上，我的卷積層的輸出是 s1

61
00:03:00,800 --> 00:03:04,080
最大池化的輸出是 p1

62
00:03:04,080 --> 00:03:09,440
好的，讓我們回到這個第二次操作的輸出是 s1

63
00:03:09,440 --> 00:03:12,959
池化的輸出是 p1

64
00:03:12,959 --> 00:03:15,599
一切將會在一秒鐘內完成

65
00:03:15,599 --> 00:03:16,879
所以

66
00:03:16,879 --> 00:03:21,599
在第一層，convert2d 的輸出是 256

67
00:03:21,599 --> 00:03:26,799
因為我們沒有進行任何池化，什麼都沒有，只是會有 64 個濾波器

68
00:03:26,799 --> 00:03:30,319
到目前為止，這個的大小是 256。

69
00:03:30,319 --> 00:03:32,080
我們有 64 個過濾器

70
00:03:32,080 --> 00:03:35,200
在最大池化後，大小縮小到 128。

71
00:03:35,200 --> 00:03:36,720
現在回到代碼

72
00:03:36,720 --> 00:03:38,400
所以在這一點上

73
00:03:38,400 --> 00:03:40,879
s1 的大小為 256

74
00:03:40,879 --> 00:03:44,000
p1 的大小為 128

75
00:03:44,000 --> 00:03:46,400
這裡的 s2 大小為 128

76
00:03:46,400 --> 00:03:46,879
因為

77
00:03:46,879 --> 00:03:51,599
s2 是什麼？它來自 p1 的輸入

78
00:03:51,599 --> 00:03:55,280
是的，我們再來看一下這個圖示

79
00:03:55,280 --> 00:04:00,959
所以這是輸入，這是 p1，這個輸入進入了我的 s2

80
00:04:00,959 --> 00:04:03,360
好，就在那裡

81
00:04:03,360 --> 00:04:03,920
然後

82
00:04:03,920 --> 00:04:07,360
在 s2 操作之後，你會得到下一步

83
00:04:07,360 --> 00:04:08,159
以此類推

84
00:04:08,159 --> 00:04:12,400
那麼我們來指定某些參數

85
00:04:12,400 --> 00:04:12,959
變數

86
00:04:12,959 --> 00:04:16,079
因此，這讓我們容易定義我們的模型

87
00:04:16,079 --> 00:04:20,000
所以假設卷積輸出是 s1

88
00:04:20,000 --> 00:04:23,040
而最大池化輸出是那裡的 p1

89
00:04:23,040 --> 00:04:27,120
在這一點，這個箭頭的尖端，這兩件事

90
00:04:27,120 --> 00:04:30,320
我們需要的其中之一是 s1

91
00:04:30,320 --> 00:04:35,040
另一個是 p1，s1 對應於這個卷積層的輸出

92
00:04:35,040 --> 00:04:38,880
和 p1 對應於這個最大池化的輸出

93
00:04:38,880 --> 00:04:42,720
作為下一個的輸入，為什麼我們需要卷積的輸出

94
00:04:42,720 --> 00:04:46,400
在最大池化之前，當我們說這個時候，我在說輸出

95
00:04:46,400 --> 00:04:49,280
在最大池化之前，為什麼我需要那個？我需要那個

96
00:04:49,280 --> 00:04:54,639
這樣我才能將該輸出發送到這一層進行串接

97
00:04:54,639 --> 00:04:55,840
這就是單元的作用

98
00:04:55,840 --> 00:04:58,880
那麼如果我們回來，我拿我的 S1

99
00:04:58,880 --> 00:05:03,440
那個 S1 連接到 D4 就在那裡，這就是原因

100
00:05:03,440 --> 00:05:07,039
我希望我的 S1 作為單獨的輸出

101
00:05:07,039 --> 00:05:08,479
我希望到目前為止一切順利

102
00:05:08,479 --> 00:05:12,639
那麼我們現在繼續這個，所以 s1 p1 s2 p2 s3 p3

103
00:05:12,639 --> 00:05:15,199
每完成這些後，你會得到

104
00:05:15,199 --> 00:05:18,240
卷積輸出最大拉伸輸出

105
00:05:18,240 --> 00:05:21,120
而且你就有了基底

106
00:05:21,120 --> 00:05:23,039
好的，就在這裡

107
00:05:23,039 --> 00:05:29,120
在這之後，我們會向上移動，同時我們會有我們的解碼器，一個解碼器

108
00:05:29,120 --> 00:05:30,639
我們不需要發送

109
00:05:30,639 --> 00:05:33,600
當我們上升時會有兩個輸出，因為我們沒有做任何事

110
00:05:33,600 --> 00:05:36,880
我們所需要的只是來自這裡的輸出

111
00:05:36,880 --> 00:05:41,039
這可以作為輸入提供給下一個解碼器區塊

112
00:05:41,039 --> 00:05:45,199
所以每個解碼區塊編碼區塊我們稍後會定義

113
00:05:45,199 --> 00:05:47,440
所以輸出是 d1 d2 d3

114
00:05:47,440 --> 00:05:51,280
然後 d4 基本上是朝向你的輸出

115
00:05:51,280 --> 00:05:54,080
現在讓我們定義一下，識別一些重複的

116
00:05:54,080 --> 00:05:58,400
模式。這裡你可以看到藍色的框，這些是重複的

117
00:05:58,400 --> 00:05:59,520
卷積塊

118
00:05:59,520 --> 00:06:03,120
如果你只看這兩個藍色箭頭，就是這樣

119
00:06:03,120 --> 00:06:05,919
兩個藍色箭頭 兩個藍色箭頭 兩個藍色箭頭

120
00:06:05,919 --> 00:06:10,720
即使是回到上面，你也有卷積層對吧

121
00:06:10,720 --> 00:06:12,960
為什麼不將其定義為一個函數

122
00:06:12,960 --> 00:06:14,800
這是第一步，我們會這麼做

123
00:06:14,800 --> 00:06:16,000
那我們要怎麼做呢

124
00:06:16,000 --> 00:06:21,199
所以在我們的情況下，卷積區塊我們要定義的方式是 convert2d

125
00:06:21,199 --> 00:06:23,280
對，那是 conf2d

126
00:06:23,280 --> 00:06:25,280
然後你可以定義下一個 2D 轉換

127
00:06:25,280 --> 00:06:27,759
但我正在添加批量正則化

128
00:06:27,759 --> 00:06:33,199
所以這有點平衡了事物，批量正則化非常好

129
00:06:33,199 --> 00:06:35,280
你知道，它使得融合變得稍微容易一些

130
00:06:35,280 --> 00:06:39,199
讓我這麼說吧，再次觀看批次正規化的影片

131
00:06:39,199 --> 00:06:41,919
但只是快速提醒一下

132
00:06:41,919 --> 00:06:47,840
所以這個矩形上面寫著 64，就是這部分代碼

133
00:06:47,840 --> 00:06:51,759
基本上是 convert2d 加上批量正規化

134
00:06:51,759 --> 00:06:54,880
然後應用 Rayleigh 激活函數，就是這樣

135
00:06:54,880 --> 00:06:59,280
將濾波器大小設為三乘三

136
00:06:59,280 --> 00:07:00,880
然後是射頻激活

137
00:07:00,880 --> 00:07:04,080
我做的就是添加偏差正規化，就這樣

138
00:07:04,080 --> 00:07:06,160
然後第二個就在那裡

139
00:07:06,160 --> 00:07:10,319
這與第一個相當相似，對立批次啟用

140
00:07:10,319 --> 00:07:13,120
這是我的卷積區塊

141
00:07:13,120 --> 00:07:14,000
好的

142
00:07:14,000 --> 00:07:16,479
還有什麼在重複

143
00:07:16,479 --> 00:07:18,720
這個區塊正在重複

144
00:07:18,720 --> 00:07:22,319
卷積區塊加上最大池化

145
00:07:22,319 --> 00:07:23,280
我的意思是你可能會認為

146
00:07:23,280 --> 00:07:27,280
這些是相同的，藍色框直到那一點沒有最大池化

147
00:07:27,280 --> 00:07:29,440
紅色框是使用最大池化

148
00:07:29,440 --> 00:07:31,680
這在編碼器中也重複出現

149
00:07:31,680 --> 00:07:34,479
四乘一二三四

150
00:07:34,479 --> 00:07:37,039
那麼我們來定義編碼器區塊

151
00:07:37,039 --> 00:07:37,759
這什麼都不是

152
00:07:37,759 --> 00:07:40,880
但這是卷積區塊的組合

153
00:07:40,880 --> 00:07:42,840
和最大

154
00:07:42,840 --> 00:07:43,919
池化

155
00:07:43,919 --> 00:07:48,160
這個編碼器區塊給我們兩個輸出 s1

156
00:07:48,160 --> 00:07:48,960
或 s

157
00:07:48,960 --> 00:07:52,160
而 p 正確，這裡我叫它 x

158
00:07:52,160 --> 00:07:53,840
但把這個視為 s

159
00:07:53,840 --> 00:07:54,400
好的

160
00:07:54,400 --> 00:07:59,280
這是來自卷積區塊的輸出，即你的 x

161
00:07:59,280 --> 00:08:01,440
而 p 是來自最大池化的輸出

162
00:08:01,440 --> 00:08:02,400
所以這是這兩個

163
00:08:02,400 --> 00:08:05,680
你知道我們為什麼需要 x，我們需要 x

164
00:08:05,680 --> 00:08:09,120
這樣我們就可以與任何那個進行連接

165
00:08:09,120 --> 00:08:11,039
d 在那邊

166
00:08:11,039 --> 00:08:12,080
我們需要 p

167
00:08:12,080 --> 00:08:15,039
這樣可以進入下一個卷積塊

168
00:08:15,039 --> 00:08:17,599
或者編碼器塊，如果你想這麼稱呼的話

169
00:08:17,599 --> 00:08:18,000
好的

170
00:08:18,000 --> 00:08:19,520
還有什麼在重複

171
00:08:19,520 --> 00:08:24,879
這些綠色的方塊，對，就是這些，它們是解碼塊。我們之前有編碼塊在下方。

172
00:08:24,879 --> 00:08:28,080
現在我們有了解碼塊。編碼塊和解碼塊之間有什麼區別？

173
00:08:28,080 --> 00:08:30,479
和解碼塊，它們有點對稱。

174
00:08:30,479 --> 00:08:32,479
但在這裡我們有連接

175
00:08:32,479 --> 00:08:34,000
所以我們需要添加它

176
00:08:34,000 --> 00:08:38,080
所以讓我們繼續添加它，我的解碼器區塊接收輸入

177
00:08:38,080 --> 00:08:40,159
從前一層

178
00:08:40,159 --> 00:08:42,799
跳過功能是快捷方式

179
00:08:42,799 --> 00:08:43,839
他們稱之為

180
00:08:43,839 --> 00:08:47,600
我是說，這是用來跳過功能的快捷鍵的常見術語

181
00:08:47,600 --> 00:08:48,959
所以這就是那個意思

182
00:08:48,959 --> 00:08:52,000
和過濾器的數量

183
00:08:52,480 --> 00:08:54,320
那麼首先會發生什麼操作

184
00:08:54,320 --> 00:08:59,519
你可以看到這裡兩兩對話，所以我們將進行 2D 轉置

185
00:08:59,519 --> 00:09:02,240
或者你可以進行上採樣，然後再進行卷積

186
00:09:02,240 --> 00:09:05,760
但這只是遵循這種矛盾轉置

187
00:09:05,760 --> 00:09:07,120
並且需要多個濾波器

188
00:09:07,120 --> 00:09:10,320
所以如果我說我的濾波器數量是 256

189
00:09:10,320 --> 00:09:14,320
這就是我如果過濾器數量為 128 時得到的結果

190
00:09:14,320 --> 00:09:18,880
在這個綠色列之後的 2D 操作到這個輸出

191
00:09:18,880 --> 00:09:21,920
我需要添加從那裡來的輸入

192
00:09:21,920 --> 00:09:22,640
所以這正是

193
00:09:22,640 --> 00:09:25,040
跳過計數功能的用途

194
00:09:25,040 --> 00:09:26,959
所以連接

195
00:09:26,959 --> 00:09:28,480
這個輸出

196
00:09:28,480 --> 00:09:32,320
和跳過功能一起，這就是那個區塊

197
00:09:32,320 --> 00:09:34,000
一旦你連接

198
00:09:34,000 --> 00:09:38,640
添加卷積區塊，記住這部分是 Karma 區塊

199
00:09:38,640 --> 00:09:43,680
對，我們重複這樣做只是為了說明這部分，藍色框是卷積

200
00:09:43,680 --> 00:09:45,279
所以在串接之後

201
00:09:45,279 --> 00:09:47,200
就是做那個卷積區塊，正是如此

202
00:09:47,200 --> 00:09:50,640
我們嘗試在那裡做的卷積區塊

203
00:09:50,640 --> 00:09:52,080
那並不簡單

204
00:09:52,080 --> 00:09:52,560
好的

205
00:09:52,560 --> 00:09:53,920
所以這就是在這裡

206
00:09:53,920 --> 00:09:56,000
現在你可以稍微看到

207
00:09:56,000 --> 00:09:57,279
這如何適合

208
00:09:57,279 --> 00:09:57,680
好的

209
00:09:57,680 --> 00:09:59,680
所以這些輸出

210
00:09:59,680 --> 00:10:00,000
和

211
00:10:00,000 --> 00:10:04,480
現在讓我們把這些整合在一起以建構這個單元

212
00:10:04,480 --> 00:10:07,360
你如何將它們組合在一起？這樣就可以了

213
00:10:07,360 --> 00:10:09,200
所以

214
00:10:09,200 --> 00:10:16,720
在輸入上應用一個具有 64 個濾波器的編碼器區塊，這就是你所得到的

215
00:10:16,720 --> 00:10:18,800
編碼器區塊能給你什麼

216
00:10:18,800 --> 00:10:22,399
編碼器區塊給你的輸出是什麼，它給你

217
00:10:22,399 --> 00:10:26,079
跳過連接就像是卷積區塊的輸出

218
00:10:26,079 --> 00:10:27,519
和最大池化

219
00:10:27,519 --> 00:10:30,079
再次重申這一點，因為這很重要

220
00:10:30,079 --> 00:10:34,079
第一個，這個 x 是連接的

221
00:10:34,079 --> 00:10:36,560
p 進入下一級

222
00:10:36,560 --> 00:10:37,040
好的

223
00:10:37,040 --> 00:10:40,079
那我們回到之前的

224
00:10:40,720 --> 00:10:42,720
它給你兩樣東西，對吧

225
00:10:42,720 --> 00:10:44,480
現在我稱它為 s1

226
00:10:44,480 --> 00:10:45,519
和 p1

227
00:10:45,519 --> 00:10:50,800
p1 是進入下一個編碼器區塊的部分，這是下一個具有 128 的編碼器區塊

228
00:10:50,800 --> 00:10:55,040
過濾器，就是 p1 的位置，這個編碼器區塊給你 s2

229
00:10:55,040 --> 00:10:56,399
以及 p2 作為輸出

230
00:10:56,399 --> 00:11:01,839
然後它一直延續到這個基礎 b1

231
00:11:01,839 --> 00:11:06,800
然後在這裡的解碼器區塊，我們正在處理 b1

232
00:11:06,800 --> 00:11:08,240
就在那裡

233
00:11:08,240 --> 00:11:12,560
然後我們將那部分複製到這裡或將那部分連接到這裡

234
00:11:12,560 --> 00:11:15,839
這是 s4 對吧

235
00:11:15,839 --> 00:11:18,640
是的，就在那裡，抱歉，s4

236
00:11:18,640 --> 00:11:22,880
這個是 s4，我把它放在這裡，可能有點混淆

237
00:11:22,880 --> 00:11:26,320
但 s4 是來自這裡的卷積輸出

238
00:11:26,320 --> 00:11:28,720
所以你把 s4 和 d1 放在一起

239
00:11:28,720 --> 00:11:30,000
然後你放入 s3

240
00:11:30,000 --> 00:11:35,200
就是從這裡出來的這個，還有 d2 對吧

241
00:11:35,200 --> 00:11:40,240
d d1 s3 對不起 d1 就在那裡 s3

242
00:11:40,240 --> 00:11:42,320
然後來到 d2 s2

243
00:11:42,320 --> 00:11:43,120
以此類推

244
00:11:43,120 --> 00:11:45,120
所以你把這些東西串聯在一起

245
00:11:45,120 --> 00:11:45,920
如果我錯了

246
00:11:45,920 --> 00:11:46,640
繼續修正

247
00:11:46,640 --> 00:11:49,839
它，但我們將在下一部分檢查它

248
00:11:49,839 --> 00:11:52,160
你知道，在本教程的下一部分

249
00:11:52,160 --> 00:11:53,600
我們無論如何都會查看代碼

250
00:11:53,600 --> 00:11:56,959
所以如果有任何不匹配的地方，請不要擔心

251
00:11:56,959 --> 00:11:58,240
但我不認為會有任何

252
00:11:58,240 --> 00:12:00,399
只是先跟你打個預防針

253
00:12:00,399 --> 00:12:01,120
所以最終

254
00:12:01,120 --> 00:12:03,680
我的輸出是什麼？我的輸出是一個卷積

255
00:12:03,680 --> 00:12:07,200
2D 操作，這是到目前為止的輸出，我們完成了

256
00:12:07,200 --> 00:12:13,360
這最終的輸出是一個 2D 操作，使用逐一核

257
00:12:13,360 --> 00:12:20,000
和激活函數 sigmoid，對吧？這在這個例子中是一個二元的

258
00:12:20,000 --> 00:12:21,440
語義分割

259
00:12:21,440 --> 00:12:22,240
所以輸出

260
00:12:22,240 --> 00:12:27,519
所以我將始終使用激活函數 sigmoid，請記住多類別分類

261
00:12:27,519 --> 00:12:29,920
軟最大激活

262
00:12:29,920 --> 00:12:31,519
二元分類

263
00:12:31,519 --> 00:12:33,120
sigmoid 激活

264
00:12:33,120 --> 00:12:35,200
但這是語意分割

265
00:12:35,200 --> 00:12:40,079
我在說什麼，語意分割與分類是相同的

266
00:12:40,079 --> 00:12:43,600
除非你在對每個像素進行分類，而不是整個圖像

267
00:12:43,600 --> 00:12:45,760
所以適用相同的規則

268
00:12:45,760 --> 00:12:46,720
好的

269
00:12:46,720 --> 00:12:48,800
所以那就是你所在的位置

270
00:12:48,800 --> 00:12:50,399
所以讓我們跳到代碼部分

271
00:12:50,399 --> 00:12:55,040
並查看我們是否能學到更多

272
00:12:55,040 --> 00:12:55,600
好的

273
00:12:55,600 --> 00:12:57,120
所以完全相同的事情

274
00:12:57,120 --> 00:13:01,600
現在我正在匯入庫，讓我們繼續連接

275
00:13:01,600 --> 00:13:04,240
首先

276
00:13:04,240 --> 00:13:07,920
讓我們檢查執行時間

277
00:13:07,920 --> 00:13:10,720
更改運行時類型，我不使用 GPU

278
00:13:10,720 --> 00:13:14,000
因為在這裡我們不需要 GPU，我們只是建立一個模型

279
00:13:14,000 --> 00:13:16,880
好的，我們不會使用 GPU

280
00:13:16,880 --> 00:13:17,200
好的

281
00:13:17,200 --> 00:13:23,200
從 keras.layers 匯入 input、Convolution2D、MaxPooling2D

282
00:13:23,200 --> 00:13:24,399
如果你想使用上採樣

283
00:13:24,399 --> 00:13:27,040
你可以使用它，但我將使用 Conv2DTranspose

284
00:13:27,040 --> 00:13:28,399
正如我之前展示的

285
00:13:28,399 --> 00:13:29,920
然後你可以添加中斷

286
00:13:29,920 --> 00:13:30,480
及其他

287
00:13:30,480 --> 00:13:31,200
如果你想

288
00:13:31,200 --> 00:13:35,920
那麼我們再次進行函式庫的匯入吧，這對你來說應該不會是新鮮事

289
00:13:35,920 --> 00:13:37,760
現在讓我們來定義卷積

290
00:13:37,760 --> 00:13:41,680
區塊，我不想重複我談過的所有內容，這實際上是

291
00:13:41,680 --> 00:13:44,399
我們之前看到的，卷積區塊

292
00:13:44,399 --> 00:13:45,920
演示中的 OK

293
00:13:45,920 --> 00:13:47,680
現在編碼器區塊什麼都沒有

294
00:13:47,680 --> 00:13:51,040
只有具有最大池化的卷積區塊

295
00:13:51,040 --> 00:13:53,839
然後我們會給出卷積區塊的輸出

296
00:13:53,839 --> 00:13:57,199
和最大池化，我們將返回這兩個

297
00:13:57,199 --> 00:14:03,040
而這些中的一個將作為下一步的輸入

298
00:14:03,040 --> 00:14:03,920
解碼器區塊

299
00:14:03,920 --> 00:14:06,000
所以我們來定義解碼器

300
00:14:06,000 --> 00:14:09,839
這就是我們構建單元的方式

301
00:14:09,839 --> 00:14:14,000
我早些時候在這段視頻錄製中添加了這個功能

302
00:14:14,000 --> 00:14:15,040
哪裡

303
00:14:15,040 --> 00:14:16,959
我說好，如果我的類別數量

304
00:14:16,959 --> 00:14:20,639
因為這是其中的一個輸入，如果我的類別數量等於 1

305
00:14:20,639 --> 00:14:26,320
這意味著它是一個二元分類，記住二元分類意味著你只有一個類別

306
00:14:26,320 --> 00:14:27,360
和

307
00:14:27,360 --> 00:14:30,959
問題被定義為背景為零

308
00:14:30,959 --> 00:14:32,240
或者一

309
00:14:32,240 --> 00:14:33,760
這是二進位的

310
00:14:33,760 --> 00:14:35,120
所以你有一個黑暗的背景

311
00:14:35,120 --> 00:14:37,920
而你的物體是明亮的

312
00:14:37,920 --> 00:14:39,440
所以這是二元分類

313
00:14:39,440 --> 00:14:42,720
所以這是零或一，所以如果是這種情況，使用 sigmoid

314
00:14:42,720 --> 00:14:45,360
否則使用激活函數如 soft max

315
00:14:45,360 --> 00:14:47,120
所以我們可以在任何情況下調用這個

316
00:14:47,120 --> 00:14:50,320
無論你知道多少

317
00:14:50,320 --> 00:14:52,320
你要分割的類別數量

318
00:14:52,320 --> 00:14:52,639
好的

319
00:14:52,639 --> 00:14:54,320
那麼我們就開始吧

320
00:14:54,320 --> 00:14:58,959
那麼讓我們建立我們的單元，假設我的輸入形狀不僅僅是灰階

321
00:14:58,959 --> 00:15:02,000
而是一張顏色圖片 256x256x3

322
00:15:02,000 --> 00:15:07,600
而且我的類別數量等於 1。繼續並打印摘要

323
00:15:07,600 --> 00:15:10,480
所以這是摘要，讓我們往下滾動

324
00:15:10,480 --> 00:15:12,560
然後從最上面開始

325
00:15:12,560 --> 00:15:16,639
來了，它以 256 256 3 作為你的輸入層開始

326
00:15:16,639 --> 00:15:19,600
然後 64 64 右邊

327
00:15:19,600 --> 00:15:22,320
一直往下到 1024

328
00:15:22,320 --> 00:15:25,680
然後一直回到

329
00:15:25,680 --> 00:15:31,440
這是二元的，再次是二元分類

330
00:15:31,440 --> 00:15:32,720
所以你要麼有 0

331
00:15:32,720 --> 00:15:33,440
或 1。

332
00:15:33,440 --> 00:15:35,759
現在我們將這個改為多類別

333
00:15:35,759 --> 00:15:37,600
我們如何將這個改為多類別

334
00:15:37,600 --> 00:15:39,279
所以對於多類別

335
00:15:39,279 --> 00:15:43,759
儘管我的輸入影像仍然是彩色的，您可以將其更改為灰階

336
00:15:43,759 --> 00:15:48,240
如果是灰階，您的輸入將是 256 到 56 1 對吧

337
00:15:48,240 --> 00:15:50,560
但讓我們將其更改為彩色

338
00:15:50,560 --> 00:15:52,959
和類別數量，假設我有四個類別

339
00:15:52,959 --> 00:15:58,560
四個不同的區域，我想在語義分割中識別，輸入四

340
00:15:58,560 --> 00:16:01,920
你會看到輸出層，它必須顯示四個

341
00:16:01,920 --> 00:16:02,399
好的

342
00:16:02,399 --> 00:16:03,839
那我們就往下走

343
00:16:03,839 --> 00:16:07,519
然後你就這樣完成了 256 到 56 4。

344
00:16:07,519 --> 00:16:08,480
好的

345
00:16:08,480 --> 00:16:11,680
然後一旦你有了模型，你只需要編譯

346
00:16:11,680 --> 00:16:12,320
在這裡

347
00:16:12,320 --> 00:16:18,000
我是否印出了啟動碼只是為了展示給你

348
00:16:18,000 --> 00:16:20,320
抱歉，我們回到上面去

349
00:16:20,320 --> 00:16:21,680
是的，你可以列印啟用

350
00:16:21,680 --> 00:16:24,160
在那裡查看它是否真的使用了 soft max

351
00:16:24,160 --> 00:16:24,720
或 sigmoid

352
00:16:24,720 --> 00:16:27,440
我是說這是相當簡單的，它應該使用 softmax

353
00:16:27,440 --> 00:16:30,399
因為這是多於一個的類別數

354
00:16:30,399 --> 00:16:31,440
好的

355
00:16:31,440 --> 00:16:34,240
所以這是讓我們往下看

356
00:16:34,240 --> 00:16:38,240
一旦你定義了模型，接著你需要編譯它對吧

357
00:16:38,240 --> 00:16:42,880
因此，對於這個模型的編譯，你可以使用隨機梯度下降法

358
00:16:42,880 --> 00:16:47,759
或者是基於隨機梯度下降法的一些東西

359
00:16:47,759 --> 00:16:48,560
優化器

360
00:16:48,560 --> 00:16:51,199
所以在這個例子中，原子

361
00:16:51,199 --> 00:16:52,639
和損失函數

362
00:16:52,639 --> 00:16:54,720
在這個例子中，二元交叉熵

363
00:16:54,720 --> 00:17:00,079
如果是多類別的話使用錯誤，對於多類別應該使用

364
00:17:00,079 --> 00:17:01,199
多類別交叉熵

365
00:17:01,199 --> 00:17:04,319
或者你知道分類交叉熵不是二元的

366
00:17:04,319 --> 00:17:07,199
好的，確保你使用正確的損失函數

367
00:17:07,199 --> 00:17:08,559
然後是指標

368
00:17:08,559 --> 00:17:12,720
我現在會使用準確率，順便提一下我應該已經提過了

369
00:17:12,720 --> 00:17:18,640
使用準確度作為語意分割的衡量指標是不好的

370
00:17:18,640 --> 00:17:22,880
嗯，這不會給你結果，它會

371
00:17:22,880 --> 00:17:25,280
你知道，它會收斂，不像

372
00:17:25,280 --> 00:17:30,960
但問題是達到 95%、98%、99% 的準確度很容易

373
00:17:30,960 --> 00:17:34,880
但結果仍然可能非常糟糕，那是因為準確度

374
00:17:34,880 --> 00:17:36,640
包含背景

375
00:17:36,640 --> 00:17:41,600
如果背景很複雜而物體很少，那麼你可以達到 98%的準確度

376
00:17:41,600 --> 00:17:43,679
那麼在這種情況下，最佳的指標是什麼呢？

377
00:17:43,679 --> 00:17:46,080
在這種情況下，最佳的指標會是某種被稱為

378
00:17:46,080 --> 00:17:49,200
交集聯合指標 IOU

379
00:17:49,200 --> 00:17:50,960
好的，這是最佳的指標

380
00:17:50,960 --> 00:17:56,320
我們會在接下來的教程中再次提到這個主題

381
00:17:56,320 --> 00:17:58,880
但現在讓我先停在這裡

382
00:17:58,880 --> 00:18:00,400
因為

383
00:18:00,400 --> 00:18:04,080
現在我們有一個運作良好的模型

384
00:18:04,080 --> 00:18:06,720
我們有這個對於二元分類有效的模型

385
00:18:06,720 --> 00:18:07,679
或多類別

386
00:18:07,679 --> 00:18:10,080
那麼我們在下一個影片中開始吧

387
00:18:10,080 --> 00:18:12,000
我們來談談二元分類

388
00:18:12,000 --> 00:18:14,799
讓我們看看如何將這應用到二元分類問題中

389
00:18:14,799 --> 00:18:18,160
然後我們接下來來看看多類別分類

390
00:18:18,160 --> 00:18:20,960
然後稍後我們會看看 3D 數據集

391
00:18:20,960 --> 00:18:24,400
所以請繼續關注，訂閱這個頻道

392
00:18:24,400 --> 00:18:25,440
讓我們在下個影片見面

